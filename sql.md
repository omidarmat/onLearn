- [Basics of SQL](#basics-of-sql)
  - [Creating a table](#creating-a-table)
  - [Deleting (droping) a table](#deleting-droping-a-table)
  - [Inserting rows](#inserting-rows)
  - [Retrieve data](#retrieve-data)
    - [With `SELECT`](#with-select)
      - [Retrieve raw columns](#retrieve-raw-columns)
      - [Retrieve calculated columns](#retrieve-calculated-columns)
    - [Filtering rows](#filtering-rows)
      - [With `WHERE`](#with-where)
  - [Update rows](#update-rows)
  - [Delete rows](#delete-rows)
- [Working with tables](#working-with-tables)
  - [Approaching database design](#approaching-database-design)
    - [Types of relationships](#types-of-relationships)
      - [Primary keys](#primary-keys)
      - [Foreign key](#foreign-key)
        - [Example 1: One-to-One relationship](#example-1-one-to-one-relationship)
        - [Example 2: One-to-Many relationship](#example-2-one-to-many-relationship)
      - [Wrap up](#wrap-up)
  - [Primary keys](#primary-keys-1)
  - [Foreign keys](#foreign-keys)
    - [Autogenerated IDs](#autogenerated-ids)
    - [Creating the foreign keys column](#creating-the-foreign-keys-column)
      - [Retrieve by the foreign key (`JOIN`)](#retrieve-by-the-foreign-key-join)
    - [Data consistency with foreign key constraints](#data-consistency-with-foreign-key-constraints)
    - [Foreign key constraints around deletion](#foreign-key-constraints-around-deletion)
- [Relating records with joins and aggregations](#relating-records-with-joins-and-aggregations)
  - [Joins](#joins)
    - [Examples](#examples)
    - [Different kinds of joins](#different-kinds-of-joins)
      - [Inner join](#inner-join)
      - [Left outer join](#left-outer-join)
      - [Right outer join](#right-outer-join)
      - [Full join](#full-join)
    - [`WHERE` with `JOIN`](#where-with-join)
    - [Three way joins](#three-way-joins)
  - [Aggregation and grouping](#aggregation-and-grouping)
    - [Grouping](#grouping)
    - [Aggregates](#aggregates)
    - [Combining `GROUP BY` and aggregates](#combining-group-by-and-aggregates)
    - [Filtering groups with `HAVING`](#filtering-groups-with-having)
- [Basics of sorting](#basics-of-sorting)
  - [Sorting variation: number](#sorting-variation-number)
  - [Sorting variation: string](#sorting-variation-string)
  - [Sorting variation: based on multiple properties](#sorting-variation-based-on-multiple-properties)
  - [`OFFSET` and `LIMIT`](#offset-and-limit)
    - [`LIMIT` and `ORDER BY` and `OFFSET`](#limit-and-order-by-and-offset)
- [`UNION`, `INTERSECRT` and `EXCEPT` with sets](#union-intersecrt-and-except-with-sets)
  - [Some rules of unions](#some-rules-of-unions)
  - [Commonalities with intersections](#commonalities-with-intersections)

# Basics of SQL

## Creating a table

In order to create a table you can use this query:

```sql
CREATE TABLE cities (
    name VARCHAR(50),
    country VARCHAR(50),
    population INTEGER,
    area INTEGER
);
```

> You should be mindful of using the ',' and ';' characters in their right position.

## Deleting (droping) a table

To delete a table along with all its records you can use this command:

```sql
DROP TABLE photos;
```

## Inserting rows

In order to insert records (rows) into the table, you can use this query:

```sql
INSERT INTO cities (name, country, population, area)
VALUES ('Tokyo', 'Japan', 38505000, 8223);
```

To insert multiple records in one go you can use this query:

```sql
INSERT INTO cities (name, country, population, area)
VALUES
    ('Delhi', 'India', 28125000, 2240),
    ('Shanghai', 'China', 22125000, 4015),
    ('Sao Paulo', 'Brazil', 20935000, 3043);
```

## Retrieve data

Retrieving data from an SQL table can be very complicated, but let's stick to the basics now.

### With `SELECT`

You can retrieve raw data from the database, or you can make the database calculate some data before returning it to you.

#### Retrieve raw columns

To retrieve data using the `SELECT` statement you can use this query:

```sql
SELECT * FROM cities;
```

Where `*` means every column. But you can also specify which data columns your want to retrieve:

```sql
SELECT name, country FROM cities;
```

#### Retrieve calculated columns

To retrieve calculated columns based on the raw data that exists in the table, you can use this query:

```sql
SELECT name, population / area FROM cities;
```

You will see in the results that the caluclated column has a title of `?column?`. You can rename the calculated column using this query:

```sql
SELECT name, population / area AS population_density
FROM cities;
```

> You can also use other math **operators** like `+`, `-`, `\*`, `/`, `^`, `|/` (square root), `@` (absolute value), `%` (remainder).

To manipulate string columns before being returned, you can use string operators or functions. For instance:

```sql
SELECT name || ', ' || country FROM cities;
```

> Note that you can use string constants (`', '` in the example above ) when manipulating string columns using string operators.

> There are also string **operators** and **functions** that you can use to manipulate string columns. These are `||` (join two strings), `CONCAT()` (join two strings), `LOWER()` (gives a lowercase string), `LENGTH()` (gives number of characters in a string), `UPPER()` (gives an uppercase string).

To use the `CONCAT()` string function to receive the exact result of the example above, you can use this query:

```sql
SELECT CONCAT(name, ', ', country) AS location
FROM cities;
```

You can stack as many string functions as you need in your query. For instance:

```sql
SELECT
  CONCAT(UPPER(name), ', ', UPPER(country)) AS location
FROM
  cities;
```

As another example:

```sql
SELECT
  UPPER(CONCAT(name, ', ', country)) AS location
FROM
  cities;
```

### Filtering rows

#### With `WHERE`

To filter rows, you can use the `WHERE` statement after `FROM`, which is where you define which table you are retrieving data from.

```sql
SELECT name, area FROM cities WHERE area > 4000
```

You may need to understand how the three parts of this query is executed by SQL in order to fully get how it works. So it just does not start from the beginning and proceed to the end. It starts from the `FROM` statement, then goes to the `WHERE` statement, and finally to the `SELECT` statement. Understanding this will help you write more complicated queries.

> Note that the query syntax formatting of the example above can also be like this:

```sql
SELECT
  name,
  area
FROM
  cities
WHERE
  area > 4000
```

> To filter rows you can use many comparison math operators like `=`, `>`, `<`, `>=`, `<=`, `IN` (is the value present in a list?), `<>` (are the values not equal), `!=`, `BETWEEN` (is the value between two other values?), `NOT IN` (is the value not present in a list?).

Let's use the `BETWEEN` operator:

```sql
SELECT
  name,
  area
FROM
  cities
WHERE
  area BETWEEN 2000 AND 4000;
```

Let's use the `IN` and `NOT IN` operator:

```sql
SELECT
  name,
  area
FROM
  cities
WHERE
  name IN ('Delhi', 'Shanghai');
```

> Note that you are not limited to use strings with the `IN` and `NOT IN` operator.

```sql
SELECT
  name,
  area
FROM
  cities
WHERE
  area NOT IN (8223, 3043);
```

> You can use as many operators in one `WHERE` statement. This is called a _Compound check_ where you can use as many `AND` and `OR` statements. Here is an example:

```sql
SELECT
  name,
  area
FROM
  cities
WHERE
  area NOT IN (8223, 3043)
  OR name = 'Delhi'
  OR name = 'Tokyo';
```

In this query you want to find all the cities that does not have an area of `8223` or `3043`, `AND` also the city must have the name `Delhi`.

> You can perform calculations in the `WHERE` statement. You just need to keep in mind that the order of execution in the filtering statement is prioritised for mathematical calculations and then comparisons. In the example below, `population` will be divided by `aread` and then the result will be compared to `6000`.

```sql
SELECT
	name,
  population / area AS population_density
FROM
	cities
WHERE
	population / area > 6000
```

> Remember that you cannot refer to the renamed calculated columns with their provided name in the `WHERE` statement. You can only refer to them by doing the calculation again in the `WHERE` statement.

## Update rows

To update a row in a table, you should use the `UPDATE` statement with the table name, and then the `SET` statement with the updating property along with its new value. Finally you have to specify which row you want to update by filtering the rows using the `WHERE` statement. So as an example:

```sql
UPDATE
  cities
SET
  population = 39505000
WHERE
  name = 'Tokyo';
```

> Remember that if you are trying to update only one specific row, the `WHERE` statement you write should be specific enough to target only one record in the table. This can become a bit tricky sometimes. There is a nice solution for this problem. [later...]

## Delete rows

To delete a specific row from a table, you should use the `DELETE FROM` statement followed by the table name, and then the `WHERE` statement that defines the row that is going to be deleted.

```sql
DELETE FROM cities
WHERE name = 'Tokyo';
```

> Remember that if you are trying to update only one specific row, the `WHERE` statement you write should be specific enough to target only one record in the table. This can become a bit tricky sometimes. There is a nice solution for this problem. [later...]

# Working with tables

Things are going to get closer to real-world conditions now. We are going to work with multiple tables in one database. In this part of this tutorial we are going to design a database for a photo-sharing application.

## Approaching database design

Let's talk about a few tips that would help you come up with your own database design that would suit your application needs.

The most important question you want to as yourself is: **What Tables should we make?**

A lot of time for any application you make, chances are it is going to have many features that are common among many other applications. There are many features out in the world (e.g. authentication, liking system, commenting systems) that many different web apps implement. Therefore, there are tons of resources online to give you suggestions on how to structure your database to implement these features.

However, you are probably going to create an app with some features that no one has ever built. To address this case, you need to take a look at some mockups of your application to see what the user interface looks like and what is the purpose of your application. Out goal here is to identify the different kinds of resources that exists inside your app. So you need to as yourself: **What type of resources exist in your app?** Then as the first step, you might want to create a separate table for each of these features or resources.

Then for each of these resources, you might want to find relationship or ownership between two types of resources. These relationships must be reflected in the database design. This is only achievable in a practical example.

Take Instagram as an example. To design the database for Instagram, we need 4 tables: users, photos, comments, likes. We also know that each user can own comments, photos and likes. We also know that photos own comments and likes by users. These are the relationships.

To represent relationships, we need some data somewhere that says, for instnace, that some specific photos belong to a specific user. We should now learn about 4 different kinds of relationships.

### Types of relationships

1. One-to-Many: for example, a user can own many photos. Also, a photo can have many different comments tied to it.
2. One-to-One: for example, a boat can only have one captain. A company can only have one CEO. A CEO can relate to only one company at a time. A student has one desk, and a desk can only belong to one student.
3. Many-to-Many: this is a bit trickier. For example, many students may be related to many classes. Many tasks may be assigned to many engineers. Many movies have many actors in them. Multiple sessions of conference calls can involve multiple employees.
4. Many-to-One: it is kind of the opposite direction of One-to-Many relationship. Many different comments can belong to one photo.

#### Primary keys

Primary keys are additional columns that you add to a lot of different tables inside all the different database your create. Every single table you make will have a primary key. The goal of a primary key is to identify an individual row inside a table. Every value inside the primary key volumn is going to be some kind of a unique value in that column. It is basically the ID of each row.

#### Foreign key

To set up a relationship between two different records, you should use a foreign key. The goal of a foreign key is to relate a record in a table, to another record in possibly another table or even in the same table.

##### Example 1: One-to-One relationship

For instance, imagine we have a table of photos and users. So to represent the relationship between a user and a photo, we should insert a foreign key of `user_id` for each record (row) in the photos table. This way, each photo will be related to a specific user. This way you would be able to query for all the photos related to a specific user (for instance, user with ID of 4).

##### Example 2: One-to-Many relationship

For instance, imaine a system like Instagram where comments are related to users and also comments are relate to a photos. Comments have one user and comments have one photo. Looking at the oposite direction, we would say that a user has many comments, and a photo has many comments. We now have to decide which table will receive the foreign keys. Here is the key: **The many side of our relationship is always going to get the foreign key column**. So now that we know a photo can have many comments, the many side is the comments. So the comments table will get the foreign keys pointing at a photo.

#### Wrap up

## Primary keys

1. Each row in every table has one primary key
2. No other row in the same table can have the same value
3. 99% of the time is called 'id'
4. It would be either an integer or a UUID
5. It will never change

## Foreign keys

1. Rows only have this if they belong to another record
2. Many rows in the same table can have the same foreign key
3. Name varies, usually called something like 'xyz_id'
4. Exactly equal to the primary key of the referenced row
5. It will change if the relationship changes

### Autogenerated IDs

When we implement a table that should have a primary key column, we can use a Postres feature which automatically creates a random ID when a new record is inserted into the row. To do this, we create the table with this syntax:

```sql
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  username VARCHAR(50)
);
```

So `SERIAL` data type tells Postgres that we want it to generated values for this column automatically. This way, when we want to insert a new user into this table, we won't have to give it an ID. The ID will be generated automatically.

Let's now add some data to this table:

```sql
INSERT INTO users (username)
VALUES
	('monahan93'),
  ('pfeffer'),
  ('si93onis'),
  ('99stroman');
```

Now if you use this command to take a look at all your records in this table:

```sql
SELECT * FROM users
```

You will see that each row has a unique ID which is number. It starts from 1 for the first user to 4 for the last.

### Creating the foreign keys column

Following the previous example, we are now going to create a photos table where we are going to store a foreign key of `user_id` for each photo record.

```sql
CREATE TABLE photos (
  id SERIAL PRIMARY KEY,
  url VARCHAR(200),
  user_id INTEGER REFERENCES users(id)
  );
```

Note that the foregin key column is define as the `user_id`, which holds the `INTEGER` value type, which `REFERENCES` to the `id` column of the `users` table. Marking a column as foreign key enforces some level of data consistency.

Let's now insert rows into this table.

```sql
INSERT INTO photos(url, user_id)
VALUES
	('http://two.jpg', 1),
  ('http://three.jpg', 1),
  ('http://four.jpg', 1),
  ('http://five.jpg', 2),
  ('http://six.jpg', 3),
  ('http://six.jpg', 4);
```

We can now see that in the record of this photo in the table, we have a `user_id` of `4`. ut how is this going to help us with the relationship? There two big advantages here:

1. We can start to write a lot of interesting queries that allow us to fetch all the different photos that are associated with a user.
2. We also start to get a little bit of **data consistency**.

#### Retrieve by the foreign key (`JOIN`)

Let's now write some query that uses the foreign key that we implemented.

To fetch all the photos related to a user with id of `4`. We can do it in a simple way.

```sql
SELECT
  *
FROM
  photos
WHERE
  user_id = 4;
```

But let's now actually utilize the foreign key of each photo, and list the photos along with the username that owns the photo. So we want to receive a list of photos where, instead of some integers as `user_id`s, actual usernames are listed. So what we want basically is to get images from the photos table and usernames from the users table and get them in one new table as a result of a query. This means that we need to somehow `JOIN` the two tables. We will explain more about this complicated syntax later. [later...]

```sql
SELECT url, username FROM photos
JOIN users ON users.id = photos.user_id;
```

### Data consistency with foreign key constraints

Data consistency refers to the ability of our database to make sure that the information we are inserting into it and working with it actually makes sense, and that all the references between tables actually line up. When we insert a photo record into the photos table, there are 3 possibilities that we need to consider:

- We insert a photo that is tied to a user that exists: everything is fine.
- We insert a photo that refers to a user that does not exist: this does not make sense. We are going to end up with an error. So Postgres automatically validates the reference to make sure the `user_id` matches with an actual user on the users table. If there is no match, Postgres will respond with error.
- We insert a photo that is not tied to any user: this is when we insert a photo into the photos table and don't provide a `user_id`. Well actually, you should not leave the field empty, but you have to put `NULL` instead. Postgres will accept this insertion. This photo record will also show up in the records if we retrieve all records `*`.

### Foreign key constraints around deletion

What happens we you want to delete a record that involves a foreign key? Imagine there are 3 photos related to user `1` inside the photos table. What happens if you delete user `1`? We would then end up with some dangling references. Now those photos refer to a user that does not exist and will never exist in future (because the ID integers are serialized).

In order to prevent this situation, when we make use of foreign keys, we can specify some options or exactly what we want to have happen when we want to delete a record that some other rows in some other table are dependant upon. Here are some options available:

1. `ON DELETE RESTRIC`: This is the default option. When you try to delete a user to which a photo is referencing, Postgres will throw an error.
2. `ON DELETE NO ACTION`: This option also throws an error but with a small difference [later...]
3. `ON DELETE CASCADE`: This will delete the user and also delete the photos related to that user.
4. `ON DELETE SET NULL`: This will set the `user_id` on the related photos to `NULL`. So the photos will remain in the database but will no longer refer to any user.
5. `ON DELETE SET DEFAULT`: This will set the `user_id` of the photo to a default value if this default value is provided. This default value should be determined at the time of creating the table.

Let's explore how we can use these options. To use the `ON DELETE CASCADE` you can use this syntax:

```sql
CREATE TABLE photos (
  id SERIAL PRIMARY KEY,
  url VARCHAR(200),
  user_id INTEGER REFERENCES users(id) ON DELETE CASCADE
);
```

Using this option is pretty common in managing the database of a forum application. Usually, when a user is deleted, their comments, posts and other related things are deleted also.

Let's now see how we use `ON DETELE SET NULL`:

```sql
CREATE TABLE photos (
  id SERIAL PRIMARY KEY,
  url VARCHAR(200),
  user_id INTEGER REFERENCES users(id) ON DELETE SET NULL
);
```

Using this option is recommended when you want to delete a user but keep the resources related to them.

# Relating records with joins and aggregations

In this part we are going to deal with some more complex queries. We are going to implement them using two important techniques: Joins and Aggregation.

## Joins

We use joins in SQL queries to produce a value or a set of rows by merging together a lot of different rows from different tables. We usually use joins anytime you are trying to answer a question related to multiple different kinds of resources. For instance, if you want to solve this question:

Find all the comments for the photo with ID `3` along with the username of the comment author.

This question is mentioning comments, photos, and users. Since you are going to deal with multiple resources, it might be a sign that you are going to need to use joins.

### Examples

As the first example we are going to answer this question: For each comment, show the contents of the comment and the username of the user who wrote the comment. This is definitely where you want to use joins.

```sql
SELECT contents, username
FROM comments
JOIN users ON users.id = comments.user_id;
```

We are now going to throughly examin what actually the `JOIN` command does. First, we know that we need some information from both comments and users. This is a sign that we need to use joins. Second, we are trying to refer to some columns or information in both tables; contents in comments, and usernames in users. This is another sign that we need to use a join.

Now about the syntax above, we start with the `FROM` statement. This is basically an initial selection of the rows that we want to operate on. This is actually taking all the rows from comments. Next comes the `JOIN` statement. This statements determines from which table we are going to join information with the table that we stated in the `FROM` statement. So we want to join users with comments. You can think of the `JOIN` statement as making a copy of each of the tables and put them next to each other, but by matching the references together in this new table. Then from this new table, we will go to the `SELECT` statement, where we determine which columns we want to be displayed finally in the database response.

Let's now solve another question: For each comment, list the contents of the comment and the URL of the photo the comment was added to.

```sql
SELECT contents, url
FROM comments
JOIN photos ON photos.id = comments.photo_id;
```

> Note that changing the order of stating tables in a join might sometimes result in different results, while other times it might work just fine and will give you the same result. The example above is one of those situations where changing the order does not matter. So the syntax below will give you the same result. We will see in which situations it will not work like this. The order matters if we are doing a [left outer join](#left-outer-join), or [right outer join](#right-outer-join).

```sql
SELECT contents, url
FROM photos
JOIN comments ON photos.id = comments.photo_id;
```

> Note that if we have two column names in the joined table that are the same, we will have to provide something called context. In this case, if we query that column name, Postgres will respond with an error saying that the column name is ambiguous. To solve this issue we should provide a context for this column name. The context is actually the name of the table from which we are targetting the column name. You insert the name with a dot right before the column name. For instance:

```sql
SELECT photos.id
FROM photos
JOIN comments ON photos.id = comments.photo_id;
```

You can also rename the column using this syntax:

```sql
SELECT photos.id AS photo_id
FROM photos
JOIN comments ON photos.id = comments.photo_id;
```

> Tables can also be renamed using the `AS` keyword. This is useful in more complex queries. After renaming the table, anywhere in the query that you are exactly referring to that table, you can use the new name you gave it.

```sql
SELECT p.id AS photo_id
FROM photos AS p
JOIN comments ON p.id = comments.photo_id;
```

> The `AS` keyword in the table renaming syntax can simply be dropped off, and the query will work just fine. But try not to do these things in your queries. Keep them readable.

### Different kinds of joins

The queries we make by **joining** tables work fine if all the records in the queried table has a **reference** to a record in another table. However, if there is a record in the queried table that does not reference any record in the other table, and we want the query to list all the items in the queried table, we would have to account for that special record with no reference. Otherwise, it won't show up.

This is a situation that can happen many times. Imagine you insert an image into the photos table with no reference in the `user_id` column.

```sql
INSERT INTO
  photos (url, user_id)
VALUES
  ('https://banner.jpg', NULL)
```

We are now going to query for all the records in the photos table by joinging in the users table.

```sql
SELECT url, username
FROM photos
JOIN users ON users.id = photos.user_id
```

The response returned by Postgres will not include the recent record that we inserted. But what if we wanted to query for all the photos so that we could analyze the whole memory amount occupied by them? We need to somehow include that photo in the result of our query.

Currently, the join logic will only list photos that satisfy the join condition. To go around this limit, we need to learn about different kinds of joins.

#### Inner join

Photos table | Users table

Whenever you use the `JOIN` statement by itself in a query, that is by default an inner join. Alternatively, you can write `INNER JOIN` to explicitely indicate that you are doing an inner join.

Inner join joins two tables together. When there is a record in one table that has no reference to a record in the other table, that row is going to be dropped out of the result set.

```sql
SELECT url, username
FROM photos
JOIN users ON users.id = photos.user_id;
```

#### Left outer join

Photos table | Users table

Following the previous example, if there are any records in the photos table that does not reference to any record in the users table, those records in the photos table will not be dropped out of a query that queries for all the photos.

```sql
SELECT url, username
FROM photos
LEFT JOIN users ON users.id = photos.user_id;
```

> Changing the order of performing the query in left outer join will affect the result.

#### Right outer join

Photos table | Users table

If there are any records in the photos table that have no reference to any record in the users table, those records will be dropped out of a query that queries for all the photos. However, all the records from the users table will be included in the result set, including those that are not referenced by any of the photos.

```sql
SELECT url, username
FROM photos
RIGHT JOIN users ON users.id = photos.user_id;
```

> Changing the order of performing the query in right outer join will affect the result.

#### Full join

Photos table | USers table

This join tells that just give me everything and I dont' care whether or not there is any correct merging going on, just try to merge as many rows as possible and if you can't just include the rest of the records in the result set.

```sql
SELECT url, username
FROM photos
FULL JOIN users ON users.id = photos.user_id;
```

### `WHERE` with `JOIN`

Imagine you are going to write a query to answer this question: Users can comment on photos that they posted. List the url and contents for every photo/comment where this occured. This is easily solved by using a joins along with the `WHERE` statement. This means that you should basically try to find photos and comments that have the same `user_id`, which means users that have commented under their own photos.

The way to go is to first join the comments and photos tables where the comment's `photo_id` equals the `id`s in the photos table. This will give us the comments that are posted under some specific photos. Now in this joined table, we would want to find records where the `user_id` in both comments and photos are the same.

Here is the query:

```sql
SELECT
  url,
  contents
FROM
  comments
JOIN photos ON photos.id = comments.photo_id
WHERE
  comments.user_id = photos.user_id;
```

As you can expect, the result set will include the photo URLs and the comment contents. We cannot see who actually are these users who have posted comments under their own photos. What should we do to retrieve their usernames? We currently have no sign of the users table in this query.

### Three way joins

Three way joins are the solution to the problem that we mentioned previously. Conceptually, this is very difficult to understand, but the query syntax ends up being very straight forward.

What we should do is to first, get the three tables into the temporary, imaginary joind table. This table has the columns from all the three tables. We can first start with the comments table, and then go on to the photos table and join where `comments.photo_id` equals `photos.id`. Then we go on to the users table and join where `comments.user_id` equals `photos.user_id` and also equals `user.id`. Certainly, not all the rows in the joind table would match this triple equal condition. So the related user row in this joind table would be filled with `NULL` if the condition is not satisfied. But if it is satisfied, the user id and username will be inserted into the joind table.

So we are going to update the query like this:

```sql
SELECT
  url,
  contents,
  username
FROM
  comments
 JOIN photos ON photos.id = comments.photo_id
 JOIN users ON users.id = comments.user_id
  AND photos.user_id = users.id
```

## Aggregation and grouping

With all the queries you have written so far you have just essentially pulled out some set of rows, which was more or less the exact information passed into the database. However, as we move towards more complicated queries, we are going to introduce two additional techniques: groupings and aggregation.

The goal with these two techniques is to take a big set of values or rows and somehow condense them down to a smaller set of values. It would be challenging to select data or select columns out of the grouped information. To avoid this challenge, it is key to visualize what happens when you apply the group by keyword.

### Grouping

With grouping, we are going to reduce many rows down to fewer rows. Grouping is done using the `GROUP BY` keyword. For example, take the example query below and let's understand what it does:

```sql
SELECT user_id
FROM comments
GROUP BY user_id;
```

The `GROUP BY` keyword, your database will take a look all the rows that you have selected. Here we have selected all the rows of the comments table. It will now try to find all the unique values for `user_id` and it will create a separate row in an imaginary table. The database will then take each of the rows from the selected table and assign it to a different group row based upon that row's `user_id`.

It is extremely important to remember that in this imaginary grouped table, you can only select the `user_id` column which is the `GROUP BY` argument in the query above. If you want to select columns related to the comments table inside the new imaginary grouped table, you must use aggregate functions.

### Aggregates

The goal of aggregation is to take a set of rows and somehow calculate a single value out of them. Calculating 'most', 'least', 'greatest', 'average', etc. you are probably going to need to use aggragation. This is done by using the **aggregate functions**.

Here are some different aggregate functions that we can use:

1. `COUNT()`
2. `SUM()`
3. `AVG()`
4. `MIN()`
5. `MAX()`

Let's go through some examples with aggregate functions. Take the query below as an example:

```sql
SELECT MAX(id)
FROM comments;
```

This will simply return the commet record with the maxium value for the `id` comlumn. You can use any other aggregate function and see the results. You can understand the all these functions actually take a big column of values and performs some kind of calculation or math operation on all those different values and return just one single value.

Remember that when using an aggregate function, we cannot do a normal select next to it. For instance, you cannot `SUM(id)` and `SELECT id` at the same time in a query:

```sql
-- This is NOT OK
SELECT SUM(id), id
FROM comments;
```

So we are going to most frequently use these aggregate functions by themselves or as a part of a larger `GROUP BY` statement.

### Combining `GROUP BY` and aggregates

Back to example mentioned previously, how can you use aggregates to select columns in the grouped table? We can now add aggregate functions on top of grouping. An aggregate function will be applied to the individual sub-groups. If you use an aggregate function over the grouped table, you can then select the column related to that aggregate function.

Take the example below. You can see that columns of the original comments table can only be selected within an aggregate function. They can only be called to become the subject of an aggregate function.

```sql
SELECT user_id, COUNT(id)
FROM comments
GROUP BY user_id;
```

This specific query above is actually grouping all the comments from the comments table based on the `uder_id`. So each row in the grouped table includes all the comments of a specific user. So when you apply the `COUNT(id)` aggregate function, you are actually asking the database to count the number of comments created by each individual user.

> You can also rename the column created by an aggregate function. Following the example above:

```sql
SELECT user_id, COUNT(id) AS num_comments_created
FROM comments
GROUP BY user_id;
```

> A corner case about the `COUNT` aggregate function: the count function does not count if the given argument is `NULL`. For instance, if we count the rows in the photos table by the `user_id` column, only the photo rows that have an actualy user ID will be counted. If there is a photo with the `user_id` set to `NULL`, the `COUNT` aggregate function will not count it. To go around this limit you can pass `*` to the `COUNT` function. This is true in almost any case that we are using the `COUNT` function.

```sql
SELECT COUNT(*) FROM photos;
```

As another example, we are going to find the number of comments for each photo. This is the query to write:

```sql
SELECT photo_id, COUNT(*)
FROM comments
GROUP BY photo_id
```

As another more complicated example, imagine you have two tables, one for books and one for authors. You now want to write a query that will print an author's name and the number of books they have authored. Here is the solution:

```sql
SELECT name, COUNT(*)
FROM books
JOIN authors ON authors.id = books.author_id
GROUP BY authors.name;
-- also possitble to group by writing:
GROUP BY name;
```

### Filtering groups with `HAVING`

The `HAVING` keyword is used to filter the set of groups. It is pretty similar to `WHERE`. The difference however, is that `HAVING` is used to filter out some number of groups, while `WHERE` is used to filter out some number of rows. So you will never see `HAVING` without a `GROUP BY` statement.

Let's work with an example. We divide the question into separate parts:

1. Find the number of comments for each photo
2. Where the `photo_id` is less than 3: this is concerned with a value inside a particular row. This is `WHERE`.
3. And the photo has more than 2 comments: this is concerned with an aggregate function and filtering. This is about `HAVING`. Note that `HAVING` is going to have an `AGGREGATE` keyword inside it.

```sql
 SELECT photo_id, COUNT(*)
 FROM comments
 WHERE photo_id < 3
 GROUP BY photo_id
 HAVING COUNT(*) > 2;
```

As a more complicated example, let's do this: Find the users where the user has commented on the first 2 photos and the user added more than 2 comments on those photos. Let's first divide this question into separate parts:

1. Find the users IDs
2. Where the user has commented on the first 2 photos (photos with ID 1 or 2): this is `WHERE`. We are looking for comments that have the `photo_id` of 1 or 2.
3. And the user has added more than or equal to 2 comments on those photos: this is aggregation and filtering, which means `HAVING`.

```sql
SELECT user_id, COUNT(*)
FROM comments
WHERE photo_id < 3
GROUP BY user_id
HAVING COUNT(*) >= 2
```

> Most of the times, especially in more complicated queries, it is easier to leave the `SELECT` statement empty, write the other parts of the query, and then based upon the result you are expecting, fill in the `SELECT` statement.

Let's go for another example: Given a table of phones, print the names of manufacturers and total revenue (price \* units_sold) for all phones. Only print the manufacturers who have revenue greater than 2,000,000 for all the phones they sold.

```sql
SELECT manufacturer, SUM(price*units_sold)
FROM phones
GROUP BY manufacturer
HAVING SUM(price * units_sold) > 2000000;
```

# Basics of sorting

Sorting means to retrieve a number of rows from a table and then try to re-order those records based on the values of one of the columns.

## Sorting variation: number

For instance, if you want to sort a list of products sorted from the least expensive to the most expensive (ascending), you can the `ORDER BY` statement:

```sql
SELECT *
FROM products
ORDER BY price;
```

> The default behavior of sorting is to sort data in an ascending format. Nevertheless, you can also explicitely use the `ASC` keyword to clarify the sorting behavior.

```sql
SELECT *
FROM products
ORDER BY price ASC;
```

If you want to sort from highest to lowest price, you can use the `DESC` statement at the end of the `ORDER BY` statement.

```sql
SELECT *
FROM products
ORDER BY price DESC;
```

## Sorting variation: string

You can sort the retrieved data from a table based on string values of a column using the same syntax:

```sql
SELECT *
FROM products
ORDER BY name;
```

> Keywords `ASC` and `DESC` works just like before.

## Sorting variation: based on multiple properties

Imagine you are sorting the products list by price, and then you see multiple products with the same price, and you want these products to be sorted based on some other property. So you have to sort the records based on more than just one property.

To do this you can simply state another column in the `ORDER BY` statement.

```sql
SELECT *
FROM products
ORDER BY price, weight;
```

Now if two products happen to have the same price, they will be sorted ascendingly based on their weight value.

> `ASC` and `DESC` keywords works just like before, but you would have to insert them for each column name that you have mentioned in the `ORDER BY` statement. For instance:

```sql
SELECT *
FROM products
ORDER BY price, weight DESC;
```

This means that if two products have the same price, they will be sorted descendingly regarding their weight values.

## `OFFSET` and `LIMIT`

You use `OFFSET` anytime you want to skip some number of records in a result set. For example, if you retrieve all rows from the users table and you know that there are 50 records, You can use this keyword to make Postgres skip the first 40 rows, and give you the last 10 records.

```sql
SELECT *
FROM users
OFFSET 40;
```

You use `LIMIT` when you want to constrain the number of records you get back from the result of the query. You are very likely to use `LIMIT` and `OFFSET` together. However, `LIMIT` can be used by itself.

```sql
SELECT *
FROM users
LIMIT 5;
```

> The limit value can be greater than the number of records that exist in a table.

### `LIMIT` and `ORDER BY` and `OFFSET`

As an example, you now want to order all your products by price, and then you want to retrieve the 5 least expensive products:

```sql
SELECT *
FROM products
ORDER BY price
LIMIT 5;
```

Taking this example one step further, you now want to get the 5 most expensive products except the top most expensive product:

```sql
SELECT *
FROM products
ORDER BY price DESC
LIMIT 5
OFFSET 1;
```

> Note that when using `LIMIT` and `OFFSET` together, it is a convention to insert `OFFSET` after `LIMIT`.

> `LIMIT` and `ORDER BY` are usually used in scenarios where you want to find the tops. For instance, the top five or anything like that.

> `LIMIT` and `OFFSET` are used in scenarios where you want to return results based on some pagination system in a table. So for example, if you want to display all the products to the user, you do it in a paginated format, which will present 20 products per page. This means that for the first page, you will have to return the first 20 products:

```sql
SELECT *
FROM products
ORDER BY price DESC
LIMIT 20
OFFSET 0;
```

Moving to the next page, you would have to skip the first 20 rows, and go for the second 20 rows:

```sql
SELECT *
FROM products
ORDER BY price DESC
LIMIT 20
OFFSET 20;
```

# `UNION`, `INTERSECRT` and `EXCEPT` with sets

Let's consider a realistic example: Find the 4 products with the highest price **and** the 4 products with the heighest price/weight ratio. The query for the first and second part are very different and putting them in one query is really challenging.

Let's first write the query for the first part:

```sql
SELECT *
FROM products
ORDER BY price DESC
LIMIT 4;
```

Let's now write the query for the second part:

```sql
SELECT *
FROM products
ORDER BY price / weight DESC
LIMIT 4;
```

Now to join the two queries together in order to receive one result set we can use the `UNION` keyword as below:

```sql
(
SELECT *
FROM products
ORDER BY price DESC
LIMIT 4
)
UNION
(
SELECT *
FROM products
ORDER BY price / weight DESC
LIMIT 4
);
```

> Some of the records might satisfy both queries. These records will be displayed once in the final result set. If you want those records to appear each time they satisfy a query, you can use the `UNION ALL` keyword.

```sql
(
SELECT *
FROM products
ORDER BY price DESC
LIMIT 4
)
UNION ALL
(
SELECT *
FROM products
ORDER BY price / weight DESC
LIMIT 4
);
```

## Some rules of unions

1. It is not necessary to separate the different queries using `( )`. In this specific example, we used `( )` because otherwise the database might be confused about applying the `ORDER BY` or `LIMIT` statement to just the second query or to the whole query. A union without the `( )` can look like:

```sql
SELECT * FROM products
UNION
SELECT * FROM products;
```

2. Two queries can be joined with the `UNION` keyword only if the result set of both queries have the same columns and the data type inside them must be the same also. For example, these queries cannot be unioned:

```sql
SELECT name FROM products
UNION
SELECT price FROM products;
```

It won't also work if you rename the `price` column to `name` because data types will still not be compatible.

## Commonalities with intersections

Here is a list of related keywords that are used to implement unions and intersections:

1. `UNION`: join together the result of two queries and remove duplicate rows
2. `UNION ALL`: join together results of two queries
3. `INTERSECT`: find the rows common in the results of two queries. Remove duplicates.
4. `INTERSECT ALL`: Find the rows common in the results of two queries.
5. `EXCEPT`: Find the rows that are present in first query but not second query. Remove duplicates.
6. `EXCEPT ALL`: Find the rows that are present in first query but not second query.
