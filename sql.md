- [Basics of SQL](#basics-of-sql)
  - [Creating a table](#creating-a-table)
  - [Deleting (droping) a table](#deleting-droping-a-table)
  - [Inserting rows](#inserting-rows)
  - [Retrieve data](#retrieve-data)
    - [With `SELECT`](#with-select)
      - [Retrieve raw columns](#retrieve-raw-columns)
      - [Retrieve calculated columns](#retrieve-calculated-columns)
    - [Filtering rows](#filtering-rows)
      - [With `WHERE`](#with-where)
  - [Update rows](#update-rows)
  - [Delete rows](#delete-rows)
- [Working with tables](#working-with-tables)
  - [Approaching database design](#approaching-database-design)
    - [Types of relationships](#types-of-relationships)
      - [Primary keys](#primary-keys)
      - [Foreign key](#foreign-key)
        - [Example 1: One-to-One relationship](#example-1-one-to-one-relationship)
        - [Example 2: One-to-Many relationship](#example-2-one-to-many-relationship)
      - [Wrap up](#wrap-up)
  - [Primary keys](#primary-keys-1)
  - [Foreign keys](#foreign-keys)
    - [Autogenerated IDs](#autogenerated-ids)
    - [Creating the foreign keys column](#creating-the-foreign-keys-column)
      - [Retrieve by the foreign key (`JOIN`)](#retrieve-by-the-foreign-key-join)
    - [Data consistency with foreign key constraints](#data-consistency-with-foreign-key-constraints)
    - [Foreign key constraints around deletion](#foreign-key-constraints-around-deletion)
- [Relating records with joins and aggregations](#relating-records-with-joins-and-aggregations)
  - [Joins](#joins)
    - [Examples](#examples)
    - [Different kinds of joins](#different-kinds-of-joins)
      - [Inner join](#inner-join)
      - [Left outer join](#left-outer-join)
      - [Right outer join](#right-outer-join)
      - [Full join](#full-join)
    - [`WHERE` with `JOIN`](#where-with-join)
    - [Three way joins](#three-way-joins)
  - [Aggregation and grouping](#aggregation-and-grouping)
    - [Grouping](#grouping)
    - [Aggregates](#aggregates)
    - [Combining `GROUP BY` and aggregates](#combining-group-by-and-aggregates)
    - [Filtering groups with `HAVING`](#filtering-groups-with-having)
- [Basics of sorting](#basics-of-sorting)
  - [Sorting variation: number](#sorting-variation-number)
  - [Sorting variation: string](#sorting-variation-string)
  - [Sorting variation: based on multiple properties](#sorting-variation-based-on-multiple-properties)
  - [`OFFSET` and `LIMIT`](#offset-and-limit)
    - [`LIMIT` and `ORDER BY` and `OFFSET`](#limit-and-order-by-and-offset)
- [`UNION`, `INTERSECRT` and `EXCEPT` with sets](#union-intersecrt-and-except-with-sets)
  - [Some rules of unions](#some-rules-of-unions)
  - [Commonalities with intersections](#commonalities-with-intersections)
- [Assembling queries with subqueries](#assembling-queries-with-subqueries)
  - [Subqueries in `SELECT`](#subqueries-in-select)
  - [Subqueries in `FROM`](#subqueries-in-from)
  - [Subqueries in `JOIN`](#subqueries-in-join)
  - [Subqueries in `WHERE`](#subqueries-in-where)
    - [Examples](#examples-1)
  - [Correlated subquery](#correlated-subquery)
  - [`SELECT` without a `FROM` or `JOIN`](#select-without-a-from-or-join)
- [Selecting `DISTINCT` records](#selecting-distinct-records)
- [Utility operators](#utility-operators)
  - [`GREATEST` function](#greatest-function)
  - [`LEAST` function](#least-function)
  - [`CASE` keyword](#case-keyword)
- [Postgres complex data types](#postgres-complex-data-types)
  - [Data types](#data-types)
    - [Numeric types](#numeric-types)
      - [Rules on number type](#rules-on-number-type)
    - [Character types](#character-types)
    - [Boolean types](#boolean-types)
    - [Date/time types](#datetime-types)
      - [Calculations with date and time](#calculations-with-date-and-time)
- [Database-side validation and constraints](#database-side-validation-and-constraints)
  - [Row-level validation](#row-level-validation)
    - [Applying null constraint](#applying-null-constraint)
    - [Default column values](#default-column-values)
    - [Appylying unique constraint](#appylying-unique-constraint)
      - [Multi-column uniqueness](#multi-column-uniqueness)
    - [Droping constraints](#droping-constraints)
    - [Adding validation check](#adding-validation-check)
      - [Checks over multiple columns](#checks-over-multiple-columns)
- [Database structure design patterns](#database-structure-design-patterns)
  - [Building some schema](#building-some-schema)
  - [Going through a real-wold example](#going-through-a-real-wold-example)
    - [How to build a like system](#how-to-build-a-like-system)
      - [How not to design a like system](#how-not-to-design-a-like-system)
      - [Designing a like system](#designing-a-like-system)
        - [Polymorphic associations](#polymorphic-associations)
        - [Alternative design](#alternative-design)
        - [Easier alternative](#easier-alternative)
        - [Conclusion](#conclusion)
    - [How to build a mention system](#how-to-build-a-mention-system)
      - [One table for both](#one-table-for-both)
      - [Separate tables](#separate-tables)
      - [Conclusion](#conclusion-1)
    - [How to build a hashtag system](#how-to-build-a-hashtag-system)
    - [How to build a follower system](#how-to-build-a-follower-system)
- [Implementing Design in Postgres](#implementing-design-in-postgres)
  - [Creating tables with checks](#creating-tables-with-checks)
    - [Creating the users table](#creating-the-users-table)
    - [Creating the posts table](#creating-the-posts-table)
    - [Creating the comments table](#creating-the-comments-table)
    - [Creating the likes table](#creating-the-likes-table)
    - [Creating the photo tags and caption tags tables](#creating-the-photo-tags-and-caption-tags-tables)
    - [Creaing the hashtags table](#creaing-the-hashtags-table)
- [Managing the database](#managing-the-database)
  - [Inserting data from a backup file](#inserting-data-from-a-backup-file)
  - [Restoring a database if accidentally deleted](#restoring-a-database-if-accidentally-deleted)
- [Understanding the internals of Postgres](#understanding-the-internals-of-postgres)
  - [Where does Postgres stores data on hard disk](#where-does-postgres-stores-data-on-hard-disk)
    - [Heaps, blocks and tuples](#heaps-blocks-and-tuples)
      - [Heap or heap file](#heap-or-heap-file)
      - [Tuple or item](#tuple-or-item)
      - [Block or page](#block-or-page)
  - [Block data layout](#block-data-layout)
  - [Heap file layout](#heap-file-layout)

# Basics of SQL

## Creating a table

In order to create a table you can use this query:

```sql
CREATE TABLE cities (
    name VARCHAR(50),
    country VARCHAR(50),
    population INTEGER,
    area INTEGER
);
```

> You should be mindful of using the ',' and ';' characters in their right position.

## Deleting (droping) a table

To delete a table along with all its records you can use this command:

```sql
DROP TABLE photos;
```

## Inserting rows

In order to insert records (rows) into the table, you can use this query:

```sql
INSERT INTO cities (name, country, population, area)
VALUES ('Tokyo', 'Japan', 38505000, 8223);
```

To insert multiple records in one go you can use this query:

```sql
INSERT INTO cities (name, country, population, area)
VALUES
    ('Delhi', 'India', 28125000, 2240),
    ('Shanghai', 'China', 22125000, 4015),
    ('Sao Paulo', 'Brazil', 20935000, 3043);
```

## Retrieve data

Retrieving data from an SQL table can be very complicated, but let's stick to the basics now.

### With `SELECT`

You can retrieve raw data from the database, or you can make the database calculate some data before returning it to you.

#### Retrieve raw columns

To retrieve data using the `SELECT` statement you can use this query:

```sql
SELECT * FROM cities;
```

Where `*` means every column. But you can also specify which data columns your want to retrieve:

```sql
SELECT name, country FROM cities;
```

#### Retrieve calculated columns

To retrieve calculated columns based on the raw data that exists in the table, you can use this query:

```sql
SELECT name, population / area FROM cities;
```

You will see in the results that the caluclated column has a title of `?column?`. You can rename the calculated column using this query:

```sql
SELECT name, population / area AS population_density
FROM cities;
```

> You can also use other math **operators** like `+`, `-`, `\*`, `/`, `^`, `|/` (square root), `@` (absolute value), `%` (remainder).

To manipulate string columns before being returned, you can use string operators or functions. For instance:

```sql
SELECT name || ', ' || country FROM cities;
```

> Note that you can use string constants (`', '` in the example above ) when manipulating string columns using string operators.

> There are also string **operators** and **functions** that you can use to manipulate string columns. These are `||` (join two strings), `CONCAT()` (join two strings), `LOWER()` (gives a lowercase string), `LENGTH()` (gives number of characters in a string), `UPPER()` (gives an uppercase string).

To use the `CONCAT()` string function to receive the exact result of the example above, you can use this query:

```sql
SELECT CONCAT(name, ', ', country) AS location
FROM cities;
```

You can stack as many string functions as you need in your query. For instance:

```sql
SELECT
  CONCAT(UPPER(name), ', ', UPPER(country)) AS location
FROM
  cities;
```

As another example:

```sql
SELECT
  UPPER(CONCAT(name, ', ', country)) AS location
FROM
  cities;
```

### Filtering rows

#### With `WHERE`

To filter rows, you can use the `WHERE` statement after `FROM`, which is where you define which table you are retrieving data from.

```sql
SELECT name, area FROM cities WHERE area > 4000
```

You may need to understand how the three parts of this query is executed by SQL in order to fully get how it works. So it just does not start from the beginning and proceed to the end. It starts from the `FROM` statement, then goes to the `WHERE` statement, and finally to the `SELECT` statement. Understanding this will help you write more complicated queries.

> Note that the query syntax formatting of the example above can also be like this:

```sql
SELECT
  name,
  area
FROM
  cities
WHERE
  area > 4000
```

> To filter rows you can use many comparison math operators like `=`, `>`, `<`, `>=`, `<=`, `IN` (is the value present in a list?), `<>` (are the values not equal), `!=`, `BETWEEN` (is the value between two other values?), `NOT IN` (is the value not present in a list?).

Let's use the `BETWEEN` operator:

```sql
SELECT
  name,
  area
FROM
  cities
WHERE
  area BETWEEN 2000 AND 4000;
```

Let's use the `IN` and `NOT IN` operator:

```sql
SELECT
  name,
  area
FROM
  cities
WHERE
  name IN ('Delhi', 'Shanghai');
```

> Note that you are not limited to use strings with the `IN` and `NOT IN` operator.

```sql
SELECT
  name,
  area
FROM
  cities
WHERE
  area NOT IN (8223, 3043);
```

> You can use as many operators in one `WHERE` statement. This is called a _Compound check_ where you can use as many `AND` and `OR` statements. Here is an example:

```sql
SELECT
  name,
  area
FROM
  cities
WHERE
  area NOT IN (8223, 3043)
  OR name = 'Delhi'
  OR name = 'Tokyo';
```

In this query you want to find all the cities that does not have an area of `8223` or `3043`, `AND` also the city must have the name `Delhi`.

> You can perform calculations in the `WHERE` statement. You just need to keep in mind that the order of execution in the filtering statement is prioritised for mathematical calculations and then comparisons. In the example below, `population` will be divided by `area` and then the result will be compared to `6000`.

```sql
SELECT
	name,
  population / area AS population_density
FROM
	cities
WHERE
	population / area > 6000
```

> Remember that you cannot refer to the renamed calculated columns with their provided name in the `WHERE` statement. You can only refer to them by doing the calculation again in the `WHERE` statement.

## Update rows

To update a row in a table, you should use the `UPDATE` statement with the table name, and then the `SET` statement with the updating property along with its new value. Finally you have to specify which row you want to update by filtering the rows using the `WHERE` statement. So as an example:

```sql
UPDATE
  cities
SET
  population = 39505000
WHERE
  name = 'Tokyo';
```

> Remember that if you are trying to update only one specific row, the `WHERE` statement you write should be specific enough to target only one record in the table. This can become a bit tricky sometimes. There is a nice solution for this problem. [later...]

## Delete rows

To delete a specific row from a table, you should use the `DELETE FROM` statement followed by the table name, and then the `WHERE` statement that defines the row that is going to be deleted.

```sql
DELETE FROM cities
WHERE name = 'Tokyo';
```

> Remember that if you are trying to update only one specific row, the `WHERE` statement you write should be specific enough to target only one record in the table. This can become a bit tricky sometimes. There is a nice solution for this problem. [later...]

# Working with tables

Things are going to get closer to real-world conditions now. We are going to work with multiple tables in one database. In this part of this tutorial we are going to design a database for a photo-sharing application.

## Approaching database design

Let's talk about a few tips that would help you come up with your own database design that would suit your application needs.

The most important question you want to ask yourself is: **What Tables should we make?**

A lot of time for any application you make, chances are it is going to have many features that are common among many other applications. There are many features out in the world (e.g. authentication, liking system, commenting systems) that many different web apps implement. Therefore, there are tons of resources online to give you suggestions on how to structure your database to implement these features.

However, you are probably going to create an app with some features that no one has ever built. To address this case, you need to take a look at some mockups of your application to see what the user interface looks like and what is the purpose of your application. Out goal here is to identify the different kinds of resources that exists inside your app. So you need to ask yourself: **What type of resources exist in your app?** Then as the first step, you might want to create a separate table for each of these features or resources.

Then for each of these resources, you might want to find relationship or ownership between two types of resources. These relationships must be reflected in the database design. This is only achievable in a practical example.

Take Instagram as an example. To design the database for Instagram, we need 4 tables: users, photos, comments, likes. We also know that each user can own comments, photos and likes. We also know that photos own comments and likes by users. These are the relationships.

To represent relationships, we need some data somewhere that says, for instnace, that some specific photos belong to a specific user. We should now learn about 4 different kinds of relationships.

### Types of relationships

1. One-to-Many: for example, a user can own many photos. Also, a photo can have many different comments tied to it.
2. One-to-One: for example, a boat can only have one captain. A company can only have one CEO. A CEO can relate to only one company at a time. A student has one desk, and a desk can only belong to one student.
3. Many-to-Many: this is a bit trickier. For example, many students may be related to many classes. Many tasks may be assigned to many engineers. Many movies have many actors in them. Multiple sessions of conference calls can involve multiple employees.
4. Many-to-One: it is kind of the opposite direction of One-to-Many relationship. Many different comments can belong to one photo.

#### Primary keys

Primary keys are additional columns that you add to a lot of different tables inside all the different database your create. Every single table you make will have a primary key. The goal of a primary key is to identify an individual row inside a table. Every value inside the primary key volumn is going to be some kind of a unique value in that column. It is basically the ID of each row.

#### Foreign key

To set up a relationship between two different records, you should use a foreign key. The goal of a foreign key is to relate a record in a table, to another record in possibly another table or even in the same table.

##### Example 1: One-to-One relationship

For instance, imagine we have a table of photos and users. So to represent the relationship between a user and a photo, we should insert a foreign key of `user_id` for each record (row) in the photos table. This way, each photo will be related to a specific user. This way you would be able to query for all the photos related to a specific user (for instance, user with ID of 4).

##### Example 2: One-to-Many relationship

For instance, imaine a system like Instagram where comments are related to users and also comments are relate to a photos. Comments have one user and comments have one photo. Looking at the oposite direction, we would say that a user has many comments, and a photo has many comments. We now have to decide which table will receive the foreign keys. Here is the key: **The many side of our relationship is always going to get the foreign key column**. So now that we know a photo can have many comments, the many side is the comments. So the comments table will get the foreign keys pointing at a photo.

#### Wrap up

## Primary keys

1. Each row in every table has one primary key
2. No other row in the same table can have the same value
3. 99% of the time is called 'id'
4. It would be either an integer or a UUID
5. It will never change

## Foreign keys

1. Rows only have this if they belong to another record
2. Many rows in the same table can have the same foreign key
3. Name varies, usually called something like 'xyz_id'
4. Exactly equal to the primary key of the referenced row
5. It will change if the relationship changes

### Autogenerated IDs

When we implement a table that should have a primary key column, we can use a Postres feature which automatically creates a random ID when a new record is inserted into the row. To do this, we create the table with this syntax:

```sql
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  username VARCHAR(50)
);
```

So `SERIAL` data type tells Postgres that we want it to generated values for this column automatically. This way, when we want to insert a new user into this table, we won't have to give it an ID. The ID will be generated automatically.

Let's now add some data to this table:

```sql
INSERT INTO users (username)
VALUES
	('monahan93'),
  ('pfeffer'),
  ('si93onis'),
  ('99stroman');
```

Now if you use this command to take a look at all your records in this table:

```sql
SELECT * FROM users
```

You will see that each row has a unique ID which is number. It starts from 1 for the first user to 4 for the last.

### Creating the foreign keys column

Following the previous example, we are now going to create a photos table where we are going to store a foreign key of `user_id` for each photo record.

```sql
CREATE TABLE photos (
  id SERIAL PRIMARY KEY,
  url VARCHAR(200),
  user_id INTEGER REFERENCES users(id)
  );
```

Note that the foregin key column is define as the `user_id`, which holds the `INTEGER` value type, which `REFERENCES` to the `id` column of the `users` table. Marking a column as foreign key enforces some level of data consistency.

Let's now insert rows into this table.

```sql
INSERT INTO photos(url, user_id)
VALUES
	('http://two.jpg', 1),
  ('http://three.jpg', 1),
  ('http://four.jpg', 1),
  ('http://five.jpg', 2),
  ('http://six.jpg', 3),
  ('http://six.jpg', 4);
```

We can now see that in the record of this photo in the table, we have a `user_id` of `4`. But how is this going to help us with the relationship? There two big advantages here:

1. We can start to write a lot of interesting queries that allow us to fetch all the different photos that are associated with a user.
2. We also start to get a little bit of **data consistency**.

#### Retrieve by the foreign key (`JOIN`)

Let's now write some query that uses the foreign key that we implemented.

To fetch all the photos related to a user with id of `4`. We can do it in a simple way.

```sql
SELECT
  *
FROM
  photos
WHERE
  user_id = 4;
```

But let's now actually utilize the foreign key of each photo, and list the photos along with the username that owns the photo. So we want to receive a list of photos where, instead of some integers as `user_id`s, actual usernames are listed. So what we want basically is to get images from the photos table and usernames from the users table and get them in one new table as a result of a query. This means that we need to somehow `JOIN` the two tables. We will explain more about this complicated syntax later. [later...]

```sql
SELECT url, username FROM photos
JOIN users ON users.id = photos.user_id;
```

### Data consistency with foreign key constraints

Data consistency refers to the ability of our database to make sure that the information we are inserting into it and working with it actually makes sense, and that all the references between tables actually line up. When we insert a photo record into the photos table, there are 3 possibilities that we need to consider:

- We insert a photo that is tied to a user that exists: everything is fine.
- We insert a photo that refers to a user that does not exist: this does not make sense. We are going to end up with an error. So Postgres automatically validates the reference to make sure the `user_id` matches with an actual user on the users table. If there is no match, Postgres will respond with error.
- We insert a photo that is not tied to any user: this is when we insert a photo into the photos table and don't provide a `user_id`. Well actually, you should not leave the field empty, but you have to put `NULL` instead. Postgres will accept this insertion. This photo record will also show up in the records if we retrieve all records `*`.

### Foreign key constraints around deletion

What happens we you want to delete a record that involves a foreign key? Imagine there are 3 photos related to user `1` inside the photos table. What happens if you delete user `1`? We would then end up with some dangling references. Now those photos refer to a user that does not exist and will never exist in future (because the ID integers are serialized).

In order to prevent this situation, when we make use of foreign keys, we can specify some options or exactly what we want to have happen when we want to delete a record that some other rows in some other table are dependant upon. Here are some options available:

1. `ON DELETE RESTRIC`: This is the default option. When you try to delete a user to which a photo is referencing, Postgres will throw an error.
2. `ON DELETE NO ACTION`: This option also throws an error but with a small difference [later...]
3. `ON DELETE CASCADE`: This will delete the user and also delete the photos related to that user.
4. `ON DELETE SET NULL`: This will set the `user_id` on the related photos to `NULL`. So the photos will remain in the database but will no longer refer to any user.
5. `ON DELETE SET DEFAULT`: This will set the `user_id` of the photo to a default value if this default value is provided. This default value should be determined at the time of creating the table.

Let's explore how we can use these options. To use the `ON DELETE CASCADE` you can use this syntax:

```sql
CREATE TABLE photos (
  id SERIAL PRIMARY KEY,
  url VARCHAR(200),
  user_id INTEGER REFERENCES users(id) ON DELETE CASCADE
);
```

Using this option is pretty common in managing the database of a forum application. Usually, when a user is deleted, their comments, posts and other related things are deleted also.

Let's now see how we use `ON DETELE SET NULL`:

```sql
CREATE TABLE photos (
  id SERIAL PRIMARY KEY,
  url VARCHAR(200),
  user_id INTEGER REFERENCES users(id) ON DELETE SET NULL
);
```

Using this option is recommended when you want to delete a user but keep the resources related to them.

# Relating records with joins and aggregations

In this part we are going to deal with some more complex queries. We are going to implement them using two important techniques: Joins and Aggregation.

## Joins

We use joins in SQL queries to produce a value or a set of rows by merging together a lot of different rows from different tables. We usually use joins anytime you are trying to answer a question related to multiple different kinds of resources. For instance, if you want to solve this question:

Find all the comments for the photo with ID `3` along with the username of the comment author.

This question is mentioning comments, photos, and users. Since you are going to deal with multiple resources, it might be a sign that you are going to need to use joins.

### Examples

As the first example we are going to answer this question: For each comment, show the contents of the comment and the username of the user who wrote the comment. This is definitely where you want to use joins.

```sql
SELECT contents, username
FROM comments
JOIN users ON users.id = comments.user_id;
```

We are now going to throughly examin what actually the `JOIN` command does. First, we know that we need some information from both comments and users. This is a sign that we need to use joins. Second, we are trying to refer to some columns or information in both tables; contents in comments, and usernames in users. This is another sign that we need to use a join.

Now about the syntax above, we start with the `FROM` statement. This is basically an initial selection of the rows that we want to operate on. This is actually taking all the rows from comments. Next comes the `JOIN` statement. This statements determines from which table we are going to join information with the table that we stated in the `FROM` statement. So we want to join users with comments. You can think of the `JOIN` statement as making a copy of each of the tables and put them next to each other, but by matching the references together in this new table. Then from this new table, we will go to the `SELECT` statement, where we determine which columns we want to be displayed finally in the database response.

Let's now solve another question: For each comment, list the contents of the comment and the URL of the photo the comment was added to.

```sql
SELECT contents, url
FROM comments
JOIN photos ON photos.id = comments.photo_id;
```

> Note that changing the order of stating tables in a join might sometimes result in different results, while other times it might work just fine and will give you the same result. The example above is one of those situations where changing the order does not matter. So the syntax below will give you the same result. We will see in which situations it will not work like this. The order matters if we are doing a [left outer join](#left-outer-join), or [right outer join](#right-outer-join).

```sql
SELECT contents, url
FROM photos
JOIN comments ON photos.id = comments.photo_id;
```

> Note that if we have two column names in the joined table that are the same, we will have to provide something called context. In this case, if we query that column name, Postgres will respond with an error saying that the column name is ambiguous. To solve this issue we should provide a context for this column name. The context is actually the name of the table from which we are targetting the column name. You insert the name with a dot right before the column name. For instance:

```sql
SELECT photos.id
FROM photos
JOIN comments ON photos.id = comments.photo_id;
```

You can also rename the column using this syntax:

```sql
SELECT photos.id AS photo_id
FROM photos
JOIN comments ON photos.id = comments.photo_id;
```

> Tables can also be renamed using the `AS` keyword. This is useful in more complex queries. After renaming the table, anywhere in the query that you are exactly referring to that table, you can use the new name you gave it.

```sql
SELECT p.id AS photo_id
FROM photos AS p
JOIN comments ON p.id = comments.photo_id;
```

> The `AS` keyword in the table renaming syntax can simply be dropped off, and the query will work just fine. But try not to do these things in your queries. Keep them readable.

### Different kinds of joins

The queries we make by **joining** tables work fine if all the records in the queried table has a **reference** to a record in another table. However, if there is a record in the queried table that does not reference any record in the other table, and we want the query to list all the items in the queried table, we would have to account for that special record with no reference. Otherwise, it won't show up.

This is a situation that can happen many times. Imagine you insert an image into the photos table with no reference in the `user_id` column.

```sql
INSERT INTO
  photos (url, user_id)
VALUES
  ('https://banner.jpg', NULL)
```

We are now going to query for all the records in the photos table by joinging in the users table.

```sql
SELECT url, username
FROM photos
JOIN users ON users.id = photos.user_id
```

The response returned by Postgres will not include the recent record that we inserted. But what if we wanted to query for all the photos so that we could analyze the whole memory amount occupied by them? We need to somehow include that photo in the result of our query.

Currently, the join logic will only list photos that satisfy the join condition. To go around this limit, we need to learn about different kinds of joins.

#### Inner join

Photos table | Users table

Whenever you use the `JOIN` statement by itself in a query, that is by default an inner join. Alternatively, you can write `INNER JOIN` to explicitely indicate that you are doing an inner join.

Inner join joins two tables together. When there is a record in one table that has no reference to a record in the other table, that row is going to be dropped out of the result set.

```sql
SELECT url, username
FROM photos
JOIN users ON users.id = photos.user_id;
```

#### Left outer join

Photos table | Users table

Following the previous example, if there are any records in the photos table that does not reference to any record in the users table, those records in the photos table will not be dropped out of a query that queries for all the photos.

```sql
SELECT url, username
FROM photos
LEFT JOIN users ON users.id = photos.user_id;
```

> Changing the order of performing the query in left outer join will affect the result.

#### Right outer join

Photos table | Users table

If there are any records in the photos table that have no reference to any record in the users table, those records will be dropped out of a query that queries for all the photos. However, all the records from the users table will be included in the result set, including those that are not referenced by any of the photos.

```sql
SELECT url, username
FROM photos
RIGHT JOIN users ON users.id = photos.user_id;
```

> Changing the order of performing the query in right outer join will affect the result.

#### Full join

Photos table | USers table

This join tells that just give me everything and I dont' care whether or not there is any correct merging going on, just try to merge as many rows as possible and if you can't just include the rest of the records in the result set.

```sql
SELECT url, username
FROM photos
FULL JOIN users ON users.id = photos.user_id;
```

### `WHERE` with `JOIN`

Imagine you are going to write a query to answer this question: Users can comment on photos that they posted. List the url and contents for every photo/comment where this occured. This is easily solved by using a joins along with the `WHERE` statement. This means that you should basically try to find photos and comments that have the same `user_id`, which means users that have commented under their own photos.

The way to go is to first join the comments and photos tables where the comment's `photo_id` equals the `id`s in the photos table. This will give us the comments that are posted under some specific photos. Now in this joined table, we would want to find records where the `user_id` in both comments and photos are the same.

Here is the query:

```sql
SELECT
  url,
  contents
FROM
  comments
JOIN photos ON photos.id = comments.photo_id
WHERE
  comments.user_id = photos.user_id;
```

As you can expect, the result set will include the photo URLs and the comment contents. We cannot see who actually are these users who have posted comments under their own photos. What should we do to retrieve their usernames? We currently have no sign of the users table in this query.

### Three way joins

Three way joins are the solution to the problem that we mentioned previously. Conceptually, this is very difficult to understand, but the query syntax ends up being very straight forward.

What we should do is to first, get the three tables into the temporary, imaginary joind table. This table has the columns from all the three tables. We can first start with the comments table, and then go on to the photos table and join where `comments.photo_id` equals `photos.id`. Then we go on to the users table and join where `comments.user_id` equals `photos.user_id` and also equals `user.id`. Certainly, not all the rows in the joind table would match this triple equal condition. So the related user row in this joind table would be filled with `NULL` if the condition is not satisfied. But if it is satisfied, the user id and username will be inserted into the joind table.

So we are going to update the query like this:

```sql
SELECT
  url,
  contents,
  username
FROM
  comments
 JOIN photos ON photos.id = comments.photo_id
 JOIN users ON users.id = comments.user_id
  AND photos.user_id = users.id
```

## Aggregation and grouping

With all the queries you have written so far you have just essentially pulled out some set of rows, which was more or less the exact information passed into the database. However, as we move towards more complicated queries, we are going to introduce two additional techniques: groupings and aggregation.

The goal with these two techniques is to take a big set of values or rows and somehow condense them down to a smaller set of values. It would be challenging to select data or select columns out of the grouped information. To avoid this challenge, it is key to visualize what happens when you apply the group by keyword.

### Grouping

With grouping, we are going to reduce many rows down to fewer rows. Grouping is done using the `GROUP BY` keyword. For example, take the example query below and let's understand what it does:

```sql
SELECT user_id
FROM comments
GROUP BY user_id;
```

The `GROUP BY` keyword, your database will take a look all the rows that you have selected. Here we have selected all the rows of the comments table. It will now try to find all the unique values for `user_id` and it will create a separate row in an imaginary table. The database will then take each of the rows from the selected table and assign it to a different group row based upon that row's `user_id`.

It is extremely important to remember that in this imaginary grouped table, you can only select the `user_id` column which is the `GROUP BY` argument in the query above. If you want to select columns related to the comments table inside the new imaginary grouped table, you must use aggregate functions.

### Aggregates

The goal of aggregation is to take a set of rows and somehow calculate a single value out of them. Calculating 'most', 'least', 'greatest', 'average', etc. you are probably going to need to use aggragation. This is done by using the **aggregate functions**.

Here are some different aggregate functions that we can use:

1. `COUNT()`
2. `SUM()`
3. `AVG()`
4. `MIN()`
5. `MAX()`

Let's go through some examples with aggregate functions. Take the query below as an example:

```sql
SELECT MAX(id)
FROM comments;
```

This will simply return the commet record with the maxium value for the `id` comlumn. You can use any other aggregate function and see the results. You can understand the all these functions actually take a big column of values and performs some kind of calculation or math operation on all those different values and return just one single value.

Remember that when using an aggregate function, we cannot do a normal select next to it. For instance, you cannot `SUM(id)` and `SELECT id` at the same time in a query:

```sql
-- This is NOT OK
SELECT SUM(id), id
FROM comments;
```

So we are going to most frequently use these aggregate functions by themselves or as a part of a larger `GROUP BY` statement.

### Combining `GROUP BY` and aggregates

Back to example mentioned previously, how can you use aggregates to select columns in the grouped table? We can now add aggregate functions on top of grouping. An aggregate function will be applied to the individual sub-groups. If you use an aggregate function over the grouped table, you can then select the column related to that aggregate function.

Take the example below. You can see that columns of the original comments table can only be selected within an aggregate function. They can only be called to become the subject of an aggregate function.

```sql
SELECT user_id, COUNT(id)
FROM comments
GROUP BY user_id;
```

This specific query above is actually grouping all the comments from the comments table based on the `uder_id`. So each row in the grouped table includes all the comments of a specific user. So when you apply the `COUNT(id)` aggregate function, you are actually asking the database to count the number of comments created by each individual user.

> You can also rename the column created by an aggregate function. Following the example above:

```sql
SELECT user_id, COUNT(id) AS num_comments_created
FROM comments
GROUP BY user_id;
```

> A corner case about the `COUNT` aggregate function: the count function does not count if the given argument is `NULL`. For instance, if we count the rows in the photos table by the `user_id` column, only the photo rows that have an actualy user ID will be counted. If there is a photo with the `user_id` set to `NULL`, the `COUNT` aggregate function will not count it. To go around this limit you can pass `*` to the `COUNT` function. This is true in almost any case that we are using the `COUNT` function.

```sql
SELECT COUNT(*) FROM photos;
```

As another example, we are going to find the number of comments for each photo. This is the query to write:

```sql
SELECT photo_id, COUNT(*)
FROM comments
GROUP BY photo_id
```

As another more complicated example, imagine you have two tables, one for books and one for authors. You now want to write a query that will print an author's name and the number of books they have authored. Here is the solution:

```sql
SELECT name, COUNT(*)
FROM books
JOIN authors ON authors.id = books.author_id
GROUP BY authors.name;
-- also possitble to group by writing:
GROUP BY name;
```

### Filtering groups with `HAVING`

The `HAVING` keyword is used to filter the set of groups. It is pretty similar to `WHERE`. The difference however, is that `HAVING` is used to filter out some number of groups, while `WHERE` is used to filter out some number of rows. So you will never see `HAVING` without a `GROUP BY` statement.

Let's work with an example. We divide the question into separate parts:

1. Find the number of comments for each photo
2. Where the `photo_id` is less than 3: this is concerned with a value inside a particular row. This is `WHERE`.
3. And the photo has more than 2 comments: this is concerned with an aggregate function and filtering. This is about `HAVING`. Note that `HAVING` is going to have an `AGGREGATE` keyword inside it.

```sql
 SELECT photo_id, COUNT(*)
 FROM comments
 WHERE photo_id < 3
 GROUP BY photo_id
 HAVING COUNT(*) > 2;
```

As a more complicated example, let's do this: Find the users where the user has commented on the first 2 photos and the user added more than 2 comments on those photos. Let's first divide this question into separate parts:

1. Find the users IDs
2. Where the user has commented on the first 2 photos (photos with ID 1 or 2): this is `WHERE`. We are looking for comments that have the `photo_id` of 1 or 2.
3. And the user has added more than or equal to 2 comments on those photos: this is aggregation and filtering, which means `HAVING`.

```sql
SELECT user_id, COUNT(*)
FROM comments
WHERE photo_id < 3
GROUP BY user_id
HAVING COUNT(*) >= 2
```

> Most of the times, especially in more complicated queries, it is easier to leave the `SELECT` statement empty, write the other parts of the query, and then based upon the result you are expecting, fill in the `SELECT` statement.

Let's go for another example: Given a table of phones, print the names of manufacturers and total revenue (price \* units_sold) for all phones. Only print the manufacturers who have revenue greater than 2,000,000 for all the phones they sold.

```sql
SELECT manufacturer, SUM(price*units_sold)
FROM phones
GROUP BY manufacturer
HAVING SUM(price * units_sold) > 2000000;
```

# Basics of sorting

Sorting means to retrieve a number of rows from a table and then try to re-order those records based on the values of one of the columns.

## Sorting variation: number

For instance, if you want to sort a list of products sorted from the least expensive to the most expensive (ascending), you can use the `ORDER BY` statement:

```sql
SELECT *
FROM products
ORDER BY price;
```

> The default behavior of sorting is to sort data in an ascending format. Nevertheless, you can also explicitely use the `ASC` keyword to clarify the sorting behavior.

```sql
SELECT *
FROM products
ORDER BY price ASC;
```

If you want to sort from highest to lowest price, you can use the `DESC` statement at the end of the `ORDER BY` statement.

```sql
SELECT *
FROM products
ORDER BY price DESC;
```

## Sorting variation: string

You can sort the retrieved data from a table based on string values of a column using the same syntax:

```sql
SELECT *
FROM products
ORDER BY name;
```

> Keywords `ASC` and `DESC` works just like before.

## Sorting variation: based on multiple properties

Imagine you are sorting the products list by price, and then you see multiple products with the same price, and you want these products to be sorted based on some other property. So you have to sort the records based on more than just one property.

To do this you can simply state another column in the `ORDER BY` statement.

```sql
SELECT *
FROM products
ORDER BY price, weight;
```

Now if two products happen to have the same price, they will be sorted ascendingly based on their weight value.

> `ASC` and `DESC` keywords works just like before, but you would have to insert them for each column name that you have mentioned in the `ORDER BY` statement. For instance:

```sql
SELECT *
FROM products
ORDER BY price, weight DESC;
```

This means that if two products have the same price, they will be sorted descendingly regarding their weight values.

## `OFFSET` and `LIMIT`

You use `OFFSET` anytime you want to skip some number of records in a result set. For example, if you retrieve all rows from the users table and you know that there are 50 records, You can use this keyword to make Postgres skip the first 40 rows, and give you the last 10 records.

```sql
SELECT *
FROM users
OFFSET 40;
```

You use `LIMIT` when you want to constrain the number of records you get back from the result of the query. You are very likely to use `LIMIT` and `OFFSET` together. However, `LIMIT` can be used by itself.

```sql
SELECT *
FROM users
LIMIT 5;
```

> The limit value can be greater than the number of records that exist in a table.

### `LIMIT` and `ORDER BY` and `OFFSET`

As an example, you now want to order all your products by price, and then you want to retrieve the 5 least expensive products:

```sql
SELECT *
FROM products
ORDER BY price
LIMIT 5;
```

Taking this example one step further, you now want to get the 5 most expensive products except the top most expensive product:

```sql
SELECT *
FROM products
ORDER BY price DESC
LIMIT 5
OFFSET 1;
```

> Note that when using `LIMIT` and `OFFSET` together, it is a convention to insert `OFFSET` after `LIMIT`.

> `LIMIT` and `ORDER BY` are usually used in scenarios where you want to find the tops. For instance, the top five or anything like that.

> `LIMIT` and `OFFSET` are used in scenarios where you want to return results based on some pagination system in a table. So for example, if you want to display all the products to the user, you do it in a paginated format, which will present 20 products per page. This means that for the first page, you will have to return the first 20 products:

```sql
SELECT *
FROM products
ORDER BY price DESC
LIMIT 20
OFFSET 0;
```

Moving to the next page, you would have to skip the first 20 rows, and go for the second 20 rows:

```sql
SELECT *
FROM products
ORDER BY price DESC
LIMIT 20
OFFSET 20;
```

# `UNION`, `INTERSECRT` and `EXCEPT` with sets

Let's consider a realistic example: Find the 4 products with the highest price **and** the 4 products with the heighest price/weight ratio. The query for the first and second part are very different and putting them in one query is really challenging.

Let's first write the query for the first part:

```sql
SELECT *
FROM products
ORDER BY price DESC
LIMIT 4;
```

Let's now write the query for the second part:

```sql
SELECT *
FROM products
ORDER BY price / weight DESC
LIMIT 4;
```

Now to join the two queries together in order to receive one result set we can use the `UNION` keyword as below:

```sql
(
SELECT *
FROM products
ORDER BY price DESC
LIMIT 4
)
UNION
(
SELECT *
FROM products
ORDER BY price / weight DESC
LIMIT 4
);
```

> Some of the records might satisfy both queries. These records will be displayed once in the final result set. If you want those records to appear each time they satisfy a query, you can use the `UNION ALL` keyword.

```sql
(
SELECT *
FROM products
ORDER BY price DESC
LIMIT 4
)
UNION ALL
(
SELECT *
FROM products
ORDER BY price / weight DESC
LIMIT 4
);
```

## Some rules of unions

1. It is not necessary to separate the different queries using `( )`. In this specific example, we used `( )` because otherwise the database might be confused about applying the `ORDER BY` or `LIMIT` statement to just the second query or to the whole query. A union without the `( )` can look like:

```sql
SELECT * FROM products
UNION
SELECT * FROM products;
```

2. Two queries can be joined with the `UNION` keyword only if the result set of both queries have the same columns and the data type inside them must be the same also. For example, these queries cannot be unioned:

```sql
SELECT name FROM products
UNION
SELECT price FROM products;
```

It won't also work if you rename the `price` column to `name` because data types will still not be compatible.

## Commonalities with intersections

Here is a list of related keywords that are used to implement unions and intersections:

1. `UNION`: join together the result of two queries and remove duplicate rows
2. `UNION ALL`: join together results of two queries
3. `INTERSECT`: find the rows common in the results of two queries. Remove duplicates.
4. `INTERSECT ALL`: Find the rows common in the results of two queries.
5. `EXCEPT`: Find the rows that are present in first query but not second query. Remove duplicates.
6. `EXCEPT ALL`: Find the rows that are present in first query but not second query.

> Changing the order of the queries when using `UNION` and `INTERSECT` does not change the result. However, with `EXCEPT` the result will change based on the order of queries.

# Assembling queries with subqueries

To understand why we actually need subqueries let's start with an example. You have a table that includes all the products of some hyper market. What would you do if you were to write this query: List the name and price of all products that are more expensive than all products in the Toys department.

You should first try to find all the products related to the Toys department and then find the highest price among them. Finally you woul have to find the products that are more expensive than that.

As for the first stage, you cannot simply go through all the table rows to find out about the toy products. You might have a table with thousands of rows. You should do this using a query. So to write the query above, you should actually do it in 2 different steps: First, find the most expensive product in the toys department. Then, you would use the result of the first step in a second query where you will list all the products that have a price higher than the result of the first step. In this case, you can combine these two steps into one by using a subquery.

Let's first see how we would write the two steps separately:

```sql
-- FIRST STEP
SELECT MAX(price)
FROM products
WHERE department = 'Toys';

-- SECOND STEP
SELECT name, price
FROM products
WHERE price > (result-of-first-step);
```

Now to combine these two queries into one using a subquery, we would first write the outer query, or essentially the second one and insert the first query as a subquery where we need the actual result of the first query.

```sql
SELECT name, price
FROM products
WHERE price > (
  -- THIS IS WHERE THE FIRST QUERY GOES: SUBQUERY
  );
```

Now you can put any other queries inside the `( )`.

```sql
SELECT name, price
FROM products
WHERE price > (
  SELECT MAX(price)
  FROM products
  WHERE department = 'Toys'
  );
```

Understanding subqueries can be difficult since they can be used in many places in another query. But why is it hard? Because anywhere you use a subquery, you have to change the shape or type of its returned data so that it would be usable in its outer query. Some queries might produce a single value, while others will return some rows. Some of them might even produce a column. Therefore, understanding the **shape** of query result is key.

Take these queries as examples:

```sql
SELECT * FROM orders
-- Returns many rows and many columns

SELECT id FROM orders
-- Returns many rows but one column

SELECT COUNT(*) FROM orders
-- Returns one row and one column (single value) - this is also called a scalar query.
```

## Subqueries in `SELECT`

If you are going to insert a subquery into a `SELECT` statement, your subquery would have to provide a single value. So any subquery that results in a single value can be inserted into the `SELECT` statement.

```sql
SELECT name, price, (subquery-result)
```

As an example:

```sql
SELECT name, price, (
  SELECT MAX(price) FROM products
)
FROM products
WHERE price > 867
  -- This query clearly does not provide a meaningful result. It is just an example to review the rules of subqueries.
```

## Subqueries in `FROM`

When using subqueries in a `FROM` statement, you can return a wide variety of different structure of data. It is all about making sure that the outer query is compatible with the subquery.

Take this query as an example:

```sql
SELECT
  name,
  price / weight AS price_weight_ratio
FROM
  products;
```

This will return a table with two columns: name and price_weight_ratio. Now think about this query as being a subquery for another query like this:

```sql
SELECT name, price_weight_ratio
-- name and price_weight_ratio are selected based on what the subquery returns
FROM (subquery-goes-here) AS p
-- Subqueries used in FROM statements must be followed by an alias, so you would be able to refer to them with the alias
WHERE price_weight_ratio > 5
-- This is a pretty simple and easy-to-understand example which could easily be written without the subquery in a real-world scenario.
```

So the final query will be like:

```sql
SELECT
  name,
  price_weight_ratio
FROM
  (
    SELECT
      name,
      price / weight AS price_weight_ratio
    FROM
      products
  ) AS p
WHERE
  price_weight_ratio > 5
```

But why would we want to use a subquery inside a `FROM` statement? To find out about it, let's go over this example: Find the average number of orders for all users. What we basically need to do is to calculate this: total number of orders divided by total number of users.

To do this, we can first group the orders table by user id. This way we would know how many orders each user has. We can then use this as a subquery for another main query.

```sql
SELECT
  user_id,
  COUNT(*) AS order_count
FROM
  orders
GROUP BY
  user_id
```

The main query will now use this subquery like this:

```sql
SELECT
  order_count
FROM
  (
    SELECT
      user_id,
      COUNT(*) AS order_count
    FROM
      orders
    GROUP BY
      user_id
  ) AS p
```

Now we are provided with a single column of values, and this means that we can now use the `AVG` aggregate function on the column.

```sql
SELECT
  AVG(order_count)
FROM
  (
    SELECT
      user_id,
      COUNT(*) AS order_count
    FROM
      orders
    GROUP BY
      user_id
  ) AS p
```

> There is a way to solve this query without a subquery.

## Subqueries in `JOIN`

The `JOIN` clause can receive any subquery that returns a result compatible with the `ON` clause. Let's go over an example. This is a query to find all the users that have ordered product ID 3:

```sql
SELECT user_id
FROM orders
WHERE product_id = 3;
```

This returns a table with one column called `user_id` containing some rows. We are now going to use this query as a subquery for another query like:

```sql
SELECT first_name
FROM users
JOIN (subquery-compatible-with-on) AS o
ON o.user_id = users.id
```

So the final query would be like:

```sql
SELECT
  first_name
FROM
  users
  JOIN (
    SELECT
      user_id
    FROM
      orders
    WHERE
      product_id = 3
  ) AS o ON o.user_id = users.id;
```

> This example can be solved without using any subquery. It is just an example.

## Subqueries in `WHERE`

This probably the most useful case of using subqueries. Let's go over an example: Show the ID of orders that involve a product with a price/weight ratio greater than 5.

Using subqueries inside a `WHERE` clause will require you to understand and remember how this clause works in general. The `WHERE` clause is used to filter some rows of table. There are a couple of operators that can be used inside a `WHERE` clause.

The structure of data allowed to be returned by a subquery inside a `WHERE` statement changes depending on the comparison operator used.

Going back to the example, we are first going to list all the products that have price/weight ration greater than 5.

```sql
 SELECT id
 FROM products
 WHERE price / weight > 5;
```

This returns a single column of values. This structure of data can be used inside `IN` operator within a `WHERE` statement.

```sql
SELECT id
FROM
  orders
WHERE
  product_id IN (
    SELECT
      id
    FROM
      products
    WHERE
      price / weight > 50;
  );
```

So the `IN` operator can only receive a list of values, that is a single column of values.

> This example could be solved using a simple `JOIN` statement.

Let's give you a table so you can easily see what data structure you need to provide for each operator that you can use in a `WHERE` statement.

| Operator in the `WHERE` statement | Structure of data of subquery |
| --------------------------------- | ----------------------------- |
| >                                 | Single value                  |
| <                                 | Single value                  |
| >=                                | Single value                  |
| <=                                | Single value                  |
| =                                 | Single value                  |
| <> or !=                          | Single value                  |
| IN                                | Single column                 |
| NOT IN                            | Single column                 |
| > ALL/SOME/ANY                    | Single column                 |
| < ALL/SOME/ANY                    | Single column                 |
| >= ALL/SOME/ANY                   | Single column                 |
| <= ALL/SOME/ANY                   | Single column                 |
| = ALL/SOME/ANY                    | Single column                 |
| <> ALL/SOME/ANY                   | Single column                 |

### Examples

Show the name of all products with a price greater than the average product price.

```sql
SELECT
  name
FROM
  products
WHERE
  price > (
    SELECT
      AVG(price)
    FROM
      products
  );
```

Let's go over another example: Show the name of all products that are not in the same department as products with a price less than 100.

```sql
SELECT
  name, department
FROM
  products
WHERE
  department NOT IN (
    SELECT
      department
    FROM
      products
    WHERE
      price < 100
  );
```

Another example: Show the name, department, and price of products that are more expensive than all products in the Industrial department. This example can be solved with different approaches, but we are now trying to use an operator in the `WHERE` statement that we have not used before, and that is `> ALL`. Remember that this operator can receive a single column of values resulting from a subquery:

```sql
SELECT name, department, price
FROM
  products
WHERE
  price > ALL (
    SELECT
      price
    FROM
      products
    WHERE
      department = 'Industrial'
  );
```

Let's now go over another example where you can use the `SOME` operator to receive a subquery: Show the name of products that are more expensive than at least one product in the Industrial department.

```sql
SELECT name, department, price
FROM
  products
WHERE
  price > SOME (
    SELECT price
    FROM
      products
    WHERE
      department = 'Industrial'
  );
```

## Correlated subquery

To understand what correlated subqueries, let's try to solve another example: Show the name, department, and price of the most expensive product in each department.

```sql
SELECT
  name,
  department,
  price
FROM
  products AS p1
WHERE
  p1.price = (
    SELECT
    FROM
      products as p2
    WHERE
      p2.department = p1.department
  )
```

What makes this query special, is that we are using aliases for each of the `FROM` statements, so that we can refer to them in both the subquery and the main query in order to do some filtering. This means that the two queries are working in relation to each other, like a double-nested loop.

> In the subquery, you can refer to the alias introduced in the main query.

Let's go over another example: Without using a join or a group by, print the number of orders for each product.

```sql
SELECT
  p1.name,
  (
    SELECT
      COUNT(*)
    FROM
      orders AS o1
    WHERE
      o1.product_id = p1.id
  ) AS num_orders
FROM
  products AS p1
```

As you can see, correlated subqueries can also be used inside the `SELECT` statement.

## `SELECT` without a `FROM` or `JOIN`

As long as a subquery returns one single value, you can use it in a `SELECT` statement without using any `FROM` or `JOIN` afterwards. But why would you need this? Let's go over an example.

```sql
SELECT
  (
    SELECT
      MAX(price)
    FROM
      products
  );
```

This will give you one column with only one value which is the maximum price of all the products. Let's go over another example: Print the ratio of maximum price on minimum price.

```sql
SELECT
  (
    SELECT
      MAX(price)
    FROM
      products
  ) / (
    SELECT
      MIN(price)
    FROM
      products
  );
```

You will need to use a single `SELECT` with subqueries whenever you want calculate one row of values or calculate the result of some math around some different values combined together.

# Selecting `DISTINCT` records

The `DISTINCT` keyword is always places inside a `SELECT` clause. `DISTINCT` will return all the different unique values inside a column.

For instance, if you want to see what unique departments there are in your products table, you can use this query:

```sql
SELECT DISTINCT department
FROM products;
```

You can also use this keyword to get the number of unique values.

```sql
SELECT COUNT(DISTINCT department)
FROM products
```

> `DISTINCT` is similar to `GROUP BY`. You can use `GROUP BY` instead of `DISCTINCT`, but not the other way. The difference is that `GROUP BY` can use aggregate functions to take a look at values inside each of the groups.

The `DISTINCT` keyword can receive more than one argument. This is useful when you need to get combined unique values. For instance, if you need to find every unique combination of department and name of your products:

```sql
SELECT DISTINCT department, name
FROM products;
```

> When using `DISTINCT` with more than one argument, you can no longer use the `COUNT` function on it.

# Utility operators

## `GREATEST` function

You can use the `GREATEST` function to calculate the maximum value among some given values. For instance:

```sql
SELECT GREATEST(20, 10, 30);
```

This returns `30` as result. But how would you use this on a real table? Let's go over an example: Compute the cost to ship each item in a products table. Note that shipping is the maximum of weight\*2$ or 30$.

```sql
SELECT name, weight, GREATEST(weight * 2, 30)
FROM products;
```

## `LEAST` function

You can use the `LEAST` function to calculate the minimum value among some given values.

For instance, let's say all products are on sale, and their price are the least of price\*0.5 or 400$.

```sql
SELECT name, price, LEAST(price*0.5, 400)
FROM products;
```

## `CASE` keyword

Let's go over an example to understand this: Print each product and its price. Also print a description of the price, meaning that if price is heigher then 500 then print 'hight', if it is higher than 300 then print 'medium' and else, print 'cheap'.

The `CASE` keyword is always used together with `WHEN` and `THEN` keywords.

```sql
SELECT
  name,
  price,
  CASE
    WHEN price > 600 THEN 'hight'
    WHEN price > 300 THEN 'medium'
    ELSE 'cheap'
  END
FROM
  products
```

> Any calculation is also possible inside the `WHEN` clause. IF your conditions are written in a way that some records don't satisfy any of them, they will be described as `null`.

# Postgres complex data types

## Data types

Data types determine what type of data you can store inside each table column. For instnace, a price column would probably only allow you to insert number (`INTEGER`) type.

Here is a list of data type categories you can use in Postgres. There are many different sub-types in each category:

- Numbers
- Date/Time
- Character
- Boolean
- Geometric
- Currency
- Range
- XML
- Binary
- JSON
- Arrays
- UUID

The first four categories are probably all you would have to remember to get on with Postgres.

### Numeric types

Here is a list of number data type category:

Numbers without any decimal points:

- smallint: between -32768 and +32767
- integer: between -2147583648 and -2147583647
- bigint

Numbers without decimal points but with auto increment:

- smallserial: 1 to 32767
- serial: 1 to 2147483647
- bigserial: 1 to ...

Numbers with decimal points: Here we have 2 sub-categories again

- Extreme precision:
  - decimal: 131072 digits before decimal point, 16383 after
  - numeric: 131072 before decimal point, 16383 after
- Normal precision:
  - real: 1E-37 to 1E37 with at least 6 places precision
  - double precision: 1E-307 to 1E308 with at least 15 place precision
  - float: same as real or double precision

You can use each of these sub-type names to determine what type of value you can insert into a column cell.

#### Rules on number type

There 4 main rules that you need to understand:

1. To define the `id` column of a table, mark the column as `SERIAL`.
2. To store a number with no decimal points, mark the column as `INTEGER`.
3. To store an extremely accurate number with decimals, for example for bank balances, grams of gold, or scientific calculations, mark the column as `NUMERIC`.
4. To store a number with decimals where the number doesn't need to be scientifically accurate, for example for kilograms of trash in a landfill, liters of water in a lake, air pressure in a tire, mark the column as `DOUBLE PRECISION`.

Let's now explore some detailed rules. To do this we need to execute some queries inside PGAdmin.

If you go on and execute these queries, you will see that Postgres will automatically try to infer the exact type of number that you have inserted.

```sql
SELECT (2);
-- integer

SELECT(2.0);
-- numeric
```

You can force Postgres to treat your value in a differnt way using the `::` operator.

```sql
SELECT (2.0::INTEGER);
```

Now postgres will follow your command and assign `integer` type to a value which previously was considered `numeric`.

Now try this query:

```sql
SELECT (2.0::SMALLINT);
```

Postgres will now treat your value as a small integer and convert it accordingly to `2` with no decimal point as `smallint`.

Inserting a value that is out of range for a specific type would result in error:

```sql
SELECT (999999::SMALLINT);
-- ERROR:  smallint out of range
```

Let's now explore some rules around decimals. Take this query as an example:

```sql
SELECT (1.99999::REAL - 1.99998::REAL);
-- returns 0.00001001358 (!)
```

You would normally expect the result to be `0.00001`. But what you actually get is different: `0.00001001358`. Why? Because Postgres, treats `REAL`, `DOUBLE PRECISION`, and `FLOAT` with floating point math. This kind of calculations are notorious for being womewhat inaccurate. However, since they are very efficient and fast for running calculations, they are used when you don't need extreme precision in your numeric values. Now to calculate the query precisely:

```sql
SELECT (1.99999::DECIMAL - 1.99998::DECIMAL);
SELECT (1.99999::numeric - 1.99998::numeric);
-- both return 0.00001
```

### Character types

Here is a list of data types of character category:

- To store a fixed length of 5 (or any other length) characters, mark the column as `CHAR(5)`. If a string with longer length is provided, Postgres will trim characters until it reaches the length of 5. If a string with shorter length is provided, Postgres will insert spaces to the right side until it reches the correct length.
- To insert any length of string, mark the column as `VARCHAR`.
- To insert a fixed length of 40 (or any other length) characters, mark the column as `VARCHAR(40)`. Works similar to `CHAR(40)`
- To store any length of string, mark the column as `TEXT`.

Take this query as an example:

```sql
SELECT ('alksjdhfgkwshegdf'::CHAR(3))
-- returns 'alk'

SELECT ('a'::CHAR(3))
-- returns 'a  '

SELECT ('asdfgsdfgsdfdfgsxdfg'::VARCHAR(5))
-- returns 'asdfg'

SELECT ('asdfgsdfgsdfdfgsasdfgsdfgsdfgadfsfgasdfgadfgxdfg'::TEXT)
-- returns 'asdfgsdfgsdfdfgsasdfgsdfgsdfgadfsfgasdfgadfgxdfg'
```

> There is no performance difference between these difference character types, which is unlike other databases. Just use the type that suits the needs of your application. Adding character length limit will not change anything regarding the performance, it is just a layer of data validation before it gets inserted into the database.

### Boolean types

When we talk about booleans, we are only talking about `true`, `false` and `null`. But we can also set some special values and tell Postgres to treat them as boolean. It will basically convert them into true or false.

You can provide a string of `yes` to Postgres and tell it to treat it as true. For instance, take the query below as an example:

```sql
SELECT ('yes'::BOOLEAN)
-- returns true as boolean

SELECT ('y'::BOOLEAN)
-- returns true as boolean

SELECT ('on'::BOOLEAN)
-- returns true as boolean


SELECT (1::BOOLEAN)
-- returns true as boolean

SELECT ('no'::BOOLEAN)
-- returns false as boolean

SELECT ('n'::BOOLEAN)
-- returns false as boolean

SELECT ('off'::BOOLEAN)
-- returns false as boolean

SELECT (0::BOOLEAN)
-- returns false as boolean
```

Storing `null` in a boolean typed cell, just means that there is no data. It is still boolean, but it is neither true nor false.

### Date/time types

Postgres can store date, time, time of timezones, and timestamps. Postgres is perfectly flexible. You can provide Postgres with various formats of strings and it would be translated into a date or time format. Take the examples below:

```sql
SELECT ('NOV-20-1980'::DATE);
-- returns 1980-11-20 as date

SELECT ('NOV 20 1980'::DATE);
-- returns 1980-11-20 as date

SELECT ('NOV 20, 1980'::DATE);
-- returns 1980-11-20 as date

SELECT ('1980 NOV 20'::DATE);
-- returns 1980-11-20 as date
```

Here are some examples to store time values with no time zone:

```sql
SELECT ('01:23'::TIME);
-- returns 01:23:00 as time without time zone

SELECT ('01:23 PM'::TIME);
-- returns 13:23:00 as time without time zone

SELECT ('01:23 PM'::TIME WITHOUT TIME ZONE);
-- you can explicitely determine the type of time format

SELECT ('01:23:30 PM'::TIME);
-- returns 13:23:30
```

To use time with time zone you would have to determine the name of the time zone in the string that you provide. Postgres will then convert your time to UTC value. So take these examples:

```sql
SELECT ('01:23:30 AM EST'::TIME WITH TIME ZONE);
-- returns 01:23:30-05:00 as time with time zone

SELECT ('01:23:30 AM PST'::TIME WITH TIME ZONE);
-- returns 01:23:30-08:00 as time with time zone

SELECT ('01:23:30 AM z'::TIME WITH TIME ZONE);
-- returns 01:23:30+00:00 (z is UTC) as time with time zone

SELECT ('01:23:30 AM utc'::TIME WITH TIME ZONE);
-- returns 01:23:30+00:00  as time with time zone
```

You can also store timestamp with or without a time zone attached to it. You can provide a string containing a date in any format and a time in any format and, optionally, a time zone. See examples below:

```sql
SELECT ('NOV-20-1980 1:23 AM PST'::TIMESTAMP WITH TIME ZONE);
-- returns 1980-11-20 12:53:00+03:30 as timestamp with time zone
```

#### Calculations with date and time

Postgres has many built-in functions to perform calculations on date and time values. There is actually a data type in Postgres called `INTERVAL`. It can hold the date/time duration between two date/time values.

```sql
SELECT ('1 day'::INTERVAL);
-- returns 1 day as interval

SELECT ('1 D 20 H'::INTERVAL);
-- returns 1 day 20:00:00 as interval
```

But this is not useful by itself. It only becomes useful when you can calculate durations.

```sql
SELECT ('1 D 20 H'::INTERVAL) - ('1 D'::INTERVAL)
-- returns 20:00:00

SELECT
	('NOV-20-1980 1:23 AM EST'::TIMESTAMP WITH TIME ZONE)
	-
	('1 D'::INTERVAL)
  -- returns 1980-11-19 09:53:00+03:30 as timestamp with time zone

  SELECT
	('NOV-20-1980 1:23 AM EST'::TIMESTAMP WITH TIME ZONE)
	-
	('NOV-10-1980 1:23 AM EST'::TIMESTAMP WITH TIME ZONE)
  -- (same time zones) returns 10 days as interval

  SELECT
	('NOV-20-1980 1:23 AM EST'::TIMESTAMP WITH TIME ZONE)
	-
	('NOV-10-1980 5:43 AM PST'::TIMESTAMP WITH TIME ZONE)
  -- (different time zones) returns 9 days 16:40:00 as interval
```

# Database-side validation and constraints

When a user sends some data to the server to be stored on the database, there should be some validation process on the way in order to prevent not relevant values or types to be inserted into the database. For instance, the price of a product can never have a negative value, or some fields are strictly required and cannot be left empty. There are some solutions for this. In some situations you can do validations on the back-end (server) while in others you may do it directly inside the database. This was the first scenario. The second scenario is a bit different.

Imagine the company doesn't have the required resources to create a user interface and web server to power it. So data would have to be inserted directly into the database by an admin user. Now that data validation should be performed by the database itself. Postgres has a way of implementing data validation.

So, where should you implement validations eventually? The best approach is to spread validations accross all three. There are benefits for doing it in both:

| Web server                                        | Database                                                             |
| ------------------------------------------------- | -------------------------------------------------------------------- |
| Easier to express more complex validation         | Validation still applied even if you connect with a different client |
| Far easier to apply new validation rules          | Guaranteed that validation is always applied                         |
| Many libraries to handle validation automatically | Can only apply new validation rules if all existing rows satisfy it  |

## Row-level validation

Row-level validation is done when a record is inserted into a table. Here is a list of things we can check for when a row is being inserted or updated in a table:

- Is a given value defined?
- Is a value unique in its column?
- Is a value `>`, `<`, `>=` or `<=` sine other value?

All the examples and solutions mentioned in this section are applied in PGAdmin software.

### Applying null constraint

As an example, we create a table for products with id, name, price and weight as columns.

```sql
CREATE TABLE products (
	id SERIAL PRIMARY KEY,
	name VARCHAR(40),
	department VARCHAR(40),
	price INTEGER,
	weight INTEGER
);
```

Now as you try to insert a row into this database like below, without defining the product's price, you will see that Postgres will simply accept your insertion and put `null` for the product's price in the table.

```sql
INSERT INTO products (name, department, weight)
VALUES
	('Pants', 'CLothes', 3);
```

But we now want to apply a null constraint so as to prevent such behavior for a value that we don't want to be left undefined. There are 2 ways to apply this constraint:

1. You can update the create table statement: mark your required column as `NOT NULL`.

```sql
CREATE TABLE products (
	id SERIAL PRIMARY KEY,
	name VARCHAR(40),
	department VARCHAR(40),
	price INTEGER NOT NULL,
	weight INTEGER
);
```

2. You can update a table that was created previously, using `ALTER` and `SET` command:

```sql
ALTER TABLE products
ALTER COLUMN price
SET NOT NULL;
```

There is a gotcha around this approach. When you are using this command to update the configuration of a previously created table, you will end up in an error if the target column already has null values inserted into it. The error would say: "column "price" of relation "products" contains null values". In this situations there are two options:

1. Find all the rows that have `null` for the target column and delete them. Then, you can run the command above.
2. Fina all the rows that have `null` for the target column and change their null to something else, like `99999` or anything special that will remind you that you need to update them with real data.

As for the second approach, you can use the query below to update the null values for the price column:

```sql
UPDATE products
SET price = 9999
WHERE price IS NULL;
```

> Note that you cannot write `WHERE price = NULL` to find the null prices. To check this, you need to use the `IS` operator.

You can now run the command above to update the null constraint on the table. Now you will no longer be able to leave the price field empty as you insert a row into the table:

```sql
INSERT INTO products (name, department, weight)
VALUES
	('Shoes', 'Clothes', 5);
  -- returns an error: violates not-null constraint
```

### Default column values

In some situations, the user/admin might not really know what value they should insert for a specific column. Nevertheless, the column should not be left with a null value. So you would have to set a default value for the columns that are required, but the user/admin might not always know what to insert. To set default values for a column you have two options:

1. You can update the create table statement: mark your required column as `DEFAULT` with a value:

```sql
CREATE TABLE products (
	id SERIAL PRIMARY KEY,
	name VARCHAR(40),
	department VARCHAR(40),
	price INTEGER DEFAULT 999,
	weight INTEGER,
);
```

2. You can update a previously created table using the `ALTER` and `SET` command:

```sql
ALTER TABLE products
ALTER COLUMN price
SET DEFAULT 999;
```

You can now insert a row into the table without having to provide a value for the price column, as it would contain `999` instead of `null`.

### Appylying unique constraint

If you need the values of a specific column of a table to be unique, you can set this constraint for your table. For instance, you might need to have unique names for the product tables. Again you can do this in two situations:

1. You can update the create table statement: marke the target column as `UNIQUE`:

```sql
CREATE TABLE products (
	id SERIAL PRIMARY KEY,
	name VARCHAR(40) UNIQUE,
	department VARCHAR(40),
	price INTEGER,
	weight INTEGER,
);
```

2. You can update a previously created table using the `ALTER` and `ADD` command:

```sql
ALTER TABLE products
ADD UNIQUE (name);
```

There is a gotcha around this commnad. You cannot execute this command unless all values inside the target column are already unique. So if you have duplicate values inside the target column, you would have to clean them up beforehand, otherwise you would end up in an error.

#### Multi-column uniqueness

You may want all the products in your table to have a unique combination of names and departments.

```sql
ALTER TABLE products
ADD UNIQUE (name, department);
```

### Droping constraints

In order to drop a constraint applied to your table, you can use the `DROP CONSTRAINT` command followed by the constraint name. You can find the constraint name by looking into the _Constraints_ section of your table inside PGAdmin.

```sql
ALTER TABLE products
DROP CONSTRAINT products_name_key;
```

> To see the updated list of your table constraints in PGAdmin, you would have to refresh your table in the Object Explorer panel.

### Adding validation check

When a value is inserted or updated, you can validate if the value is `>`, `>=`, `<`, `<=` than another value. For instance, to prevent the value of a column from being negative, you can add the proper validation. Again, there are two options:

1. You can update the create table statement: mark the target column with `CHECK` along with some validation inside `( )`.

```sql
CREATE TABLE products (
	id SERIAL PRIMARY KEY,
	name VARCHAR(40) UNIQUE,
	department VARCHAR(40),
	price INTEGER CHECK (price > 0),
	weight INTEGER,
);
```

2. You can update a previously created table using the `ALTER` and `ADD` command:

```sql
ALTER TABLE products
ADD CHECK (price > 0);
```

There is a gotcha around this command. It only works when you are adding or updating a row. It does not act on already existing rows.

#### Checks over multiple columns

This is when your validation check involves the value inside more than one single column. To apply this kind of check at the time of creating a table:

```sql
CREATE TABLE orders (
	id SERIAL PRIMARY KEY,
	name VARCHAR(40) NOT NULL,
	created_at TIMESTAMP NOT NULL,
	est_delivery TIMESTAMP NOT NULL,
	CHECK (created_at < est_delivery)
);
```

With this validation check, this query will work fine:

```sql
INSERT INTO orders (name, created_at, est_delivery)
VALUES
	('Shirt', '2000-NOV-20 01:00AM', '2000-NOV-25 01:00AM')
```

But this one won't work:

```sql
INSERT INTO orders (name, created_at, est_delivery)
VALUES
	('Shirt', '2000-NOV-20 01:00AM', '2000-NOV-10 01:00AM')
  -- est_deliver is not greater than created_at time.
```

# Database structure design patterns

From now on we are going to use some more advanced featrues that require more complicated database structure and schema to work. This means that we are going to work with a lot more data and more tables. You are now going to decide how many tables you should create, how they would be related, define columns and data types for the columns.

When working with many tables in a database, it is challenging to keep the structure/name of them in your head. So it is nice to document your database structure somehow. For this, you can use a **schema designer** to help guide your design.

Here is a list of schema designer software you can use:

1. dbdiagram.io
2. drawsql.app
3. sqldbm.com
4. quickdatabasediagrams.com
5. ondras.zarovi.cz/sql/demo

In this section of this tutorial we are going to simulate the database structure of Instagram.

## Building some schema

You can use the code below to create your diagrams in dbdiagram.io web application.

```sql
Table users {
  id SERIAL [pk, increment]
  created_at TIMESTAMP
  updated_at TIMESTAMP
  username VARCHAR(30)
  bio VARCHAR(400)
  avatar VARCHAR(200)
  phone VARCHAR(25)
  email VARCHAR(40)
  password VARCHAR(50)
  status VARCHAR(15)
  -- status field might need to be changed to enum type
}

Table posts {
  id SERIAL [pk, increment]
  created_at TIMESTAMP
  updated_at TIMESTAMP
  url VARCHAR(200)
  user_id INTEGER [ref: > users.id]
}

Table comments {
  id SERIAL [pk, increment]
  created_at TIMESTAMP
  updated_at TIMESTAMP
  contents VARCHAR(240)
  user_id INTEGER [ref: > users.id]
  post_id INTEGER [ref: > post.id]

}
```

> Note that we are not storing data about a user's number of posts, number of followers and number of followings. We are not going to create a column in the users table to store a number representing these amounts. Whenever you need some data that can be calculated based on the exisiting data in a database (this is called **Derived Data**), you usually don't create a column in a table to store derived data. When you need the data, you send a query to the database to calculate it right away.
>
> In this situation we have a users table, a posts table including a `user_id` column that points to specific users, and a `followers` table with a `user_id` column pointing to specific users. You can then use the queries below to count the number of posts and followers related to a specific user, for example user with ID 123. We will implement the following system at the end of this section.

```sql
SELECT COUNT(*)
FROM posts
WHERE user_id = 123;

SELECT COUNT(*)
FROM followers
WHERE user_id = 123;
```

## Going through a real-wold example

### How to build a like system

Here are some rules around likes:

1. Each user can like a specific post a single time
2. A user should be able to unlike a post
3. Need to be able to figure out how many users like post
4. Need to be able to list which users like a post
5. Something besides a post might need to be liked (comments, maybe?)
6. We might want to think about dislikes or other kinds of reactions

#### How not to design a like system

You should not add a `likes` column to the posts table. way you would have these problems:

- No way to make sure a user likes a post only once
- No way to make sure a user can only unlike a post they have liked
- No way to figure out which users like a post
- No way to remove a like if a user gets deleted

Overall, we would have no idea who liked what and this is not good!

#### Designing a like system

It is the best practice to have a table of likes, including `id`, `user_id`, and `post_id` columns. It is extremely important to note that within this table, we must have unique combinations of `user_id` and `post_id` so that each user can only like a post once. It means that the table would have to be limited to a `UNIQUE(user_id, post_id)` constraint.

This design also works fine for a favorites or a bookmarks table. It would basically mean the same thing, although they are different features.

However, this design has its limits too:

- You cannot define different kinds of reactions, such as dislike, sad about or stuff like that.
- You cannot implement a feature where a comment could be liked. Right now only a post can be liked.

So to adjust the design above to account for the mentioned limitations, you can implement a table called reactions including `id`, `user_id`, `post_id`, and `type`. The type column can contain a limited variation of values which could be strings as `like`, `love`, `care`, `funny` and `sad`. Postgres has a special data type to make sure values inserted into this column will always be one of these, and that is **enum**.

Now to address the option for users to be able to like a post or a comment. Let's try three solutions here.

##### Polymorphic associations

Polymorphic associations are generally not recommended, but they are still in use in some applications you will work on.

With this approach you will implement a table for likes that includes `id`, `user_id`, `liked_id` and `liked_type`. The `liked_type` will either contain `post` or `comment` string values in it. But there is a huge problem with this.

Remember the concept of **data consistency** that we talked about when discussing foreign keys? When you implement a `post_id` in a likes table, you are actually defining the column as containing the foreign key relating to a specific row in the posts table. So when you insert a row in the likes table with a particular `post_id`, Postgres will first look into the posts table to see if a post with that ID actually exists. But with the `liked_id` column that we implemented in our recent design we cannot define up front to which table the foreign key is actually relating to: posts or comments? We cannot know until a row is already recorded into the table. So we cannot apply the foreign key definition to the `liked_id` column when creating the table, it would just be a simple integer column. Without foreign keys, we lose data consisitency. This is not good. We should think of another design.

> Ruby on Rails projects make use of polymorphic associations like this a descent amount!

##### Alternative design

We could have a likes table which includes these columns: `id`, `user_id`, `post_id`, `comment_id`. Now when a like is attached to a post, the post ID wil be inserted and the comment id will be left `NULL` and vice versa. Note that both `post_id` and `comment_id` columns will be foreign keys relating to the posts and comments table respectively.

We might want to add a little bit of validation when a record is being inserted into this likes table. We can make sure either a post or a comment ID is defined in the record. We can also check for situations when both post and comment ID columns are filled with foreign key data in one single record. We can also check if both are left empty. This design gives us the ability to check all these scenarios. However, writing a check for these scenarios is a bit difficult:

```sql
Add CHECK of
(
  COALESCE((post_id)::BOOLEAN::INTEGER, 0)
  +
  COALESCE((comment_id)::BOOLEAN::INTEGER, 0)
) = 1
```

The `COALESCE` function receives two arguments and returns the first non-null value between them.

So the downside to this approach is that if later we are going to allow a user to like many more things, we would have trouble adding them to the table and validate record entries.

##### Easier alternative

It is a lot easier to create a couple of tables. A tables called `posts_likes` and another one called `comments_likes`. The first would include `id`, `user_id` and `post_id`, and the second one would include `id`, `user_id` and `comment_id`.

This is the most straight forward solution. This way we can add more tables if we would like to make users able to like other things than posts and comments. Data consistency is fully considered also.

The downside to this approach is that if you ever want to write a query where you will aggregate all the different kinds of likes inside the application, you would have to use a **union** or a **view** (We will talk about views later).

##### Conclusion

The second approach might be the optimal solution to this problem. We don't really need to create different tables for likes on posts and likes on comments, because there is no additional information in one compared to the other. Liking a post and a comment are pretty similar to each other; They are actually the same.

Let's now implement the design:

```sql
Table users {
  id SERIAL [pk, increment]
  created_at TIMESTAMP
  updated_at TIMESTAMP
  username VARCHAR(30)
}

Table posts {
  id SERIAL [pk, increment]
  created_at TIMESTAMP
  updated_at TIMESTAMP
  url VARCHAR(200)
  user_id INTEGER [ref: > users.id]
}

Table comments {
  id SERIAL [pk, increment]
  created_at TIMESTAMP
  updated_at TIMESTAMP
  contents VARCHAR(240)
  user_id INTEGER [ref: > users.id]
  post_id INTEGER [ref: > post.id]
}

<!-- THE FINAL APPROACH TO LIKES -->
Table likes {
  id SERIAL  [pk, increment]
  created_at TIMESTAMP
  user_id INTEGER [ref: > users.id]
  comment_id INTEGER [ref: > comments.id]
  post_id INTEGER [ref: > posts.id]
}
```

### How to build a mention system

As an intermediary step, let's make the posts able to receive captions and location coordinates. So we would simply have to add some columns to the posts table.

```sql
Table posts {
  id SERIAL [pk, increment]
  created_at TIMESTAMP
  updated_at TIMESTAMP
  url VARCHAR(200)
  user_id INTEGER [ref: > users.id]
  caption VARCHAR(240)
  lat REAL
  lng REAL
}
```

> The `REAL` type is numeric type with decimals. With this type, you are not guaranteed to have an absolutely precise number, but you will have precision at the level of 6 decimal digits. over that, Postgres will start to round off the value. For string location coordinates, this is probably enough as for data accuracy.

Now about the mention or tag system, we are going to consider two types of tags:

1. Tag on a photo: tagging a user on a photo requires us to store 3 piece of data related to this kind of tag. First, the username that was tagged, and then the point on the photo to which the tag is attached. So we would need the `user_id`, `x` and `y` in a tags table.
2. Tag in a post caption: Tags in post caption usually initiate with a `@` symbol and is highlighted. But this does not mean that we necessarily need to store something in our database. Highlighting a mention in a post caption is something that can be done easily on the front-end. But if any of the situations below are going to happen, you might need to store some data about this kind of tag in your database:

- Need to show a list of posts a user was mentioned in?
- Need to show a list of the most-often mentioned users?
- Need to notify a user when they have been mentioned?

It might seem that the two types of tags are very different. But thinking twice about it, they are actually very similar! In both situations, we are actually tag a user to a post. Their behavior is pretty similar.

#### One table for both

In this approach, we would create a table that includes both photo tags and caption tags. This table will have `id`, `user_id`, `post_id`, `x`, `y` columns, where for photo tags, columns `x` and `y` will contain numeric values, while in captions tags they are left `NULL`.

#### Separate tables

In this approach we would have a `photo_tags` table and a `caption_tags` table.

#### Conclusion

To decide between the two solutions, let's consider these:

- Do you expect to query for caption tags and photo tags at different rates? If that is the case, you might need to split the two tags in separate tables.
- Will the meaning of a photo tag change at some point? If a tag is likely to change its functionality over time, you might need to store it in a separate table. For instance, if the tag will receive likes in future.

So let's go with the second solution:

```sql
Table photo_tags {
  id SERIAL [pk, increment]
  created_at TIMESTAMP
  updated_at TIMESTAMP
  post_id INTEGER [ref: > posts.id]
  user_id INTEGER [ref: > users.id]
  x INTEGER
  y INTEGER
}

Table caption_tags {
  id SERIAL [pk, increment]
  created_at TIMESTAMP
  user_id INTEGER [ref: > users.id]
}
```

### How to build a hashtag system

Hashtags can be inserted into photo captions, comments, and profile biographies. One solution might be to create a table for hashtags in each, so `hashtags_posts`, `hashtags_comments`, `hashtags_users` tables. The post hashtags table would contain `id`, `title` and `post_id` columns and so on.

We could also implement a polymorphic association pattern and combine the three tables in one. Again to decide between these two solutions, you might ask yourself: Do you expect to run a query to see what posts/comments/users contain a given hashtag? If yes, then the first solution is fine.

We know that hastags are used only in the search feature. There you can search hastags and what you get back is a list of posts that contain that hashtag. So a hashtag is only useful for seaching posts with that hashtag, and not comments or user profiles that have used the hashtag.

So we need the `hashtag_posts` table, but we don't need the two tables `hashtags_comments` and `hashtags_users` separately. We can just get rid of them in our design.

To model the relationship between a hashtag and a post, we can do it in 2 ways:

1. A hashtags table containing `id`, `title`, `post_id` columns. This works fine, but for performance reasons, there might be a better way. In this first solution, we are very likely to end up with a table containing a lot of duplicates values in the `title` column. This will cause us to use up more storage space.
2. A table for hashtags including `id` and `title`. Another table containing posts, and another table connecting the two resources called `hashtags_posts` including `id`, `hashtag_id` and `post_id`. This third table is called a **join table**. In this second solution, we will also have duplicate IDs in the `hashtag_id` column but it will use a lot less storage space as an integer takes up much less space in storage.

Let's now implement the design:

```sql
Table hashtags {
  id SERIAL [pk, increment]
  created_at TIMESTAMP
  title VARCHAR(20)
}

Table hashtags_posts {
  id SERIAL [pk, increment]
  hashtag_id INTEGER [ref: > hashtags.id]
  post_id INTEGER [ref: > posts.id]
}
```

### How to build a follower system

There are generally two main rules around a follower system.

1. Each user can follow another user only once.
2. No user can follow themselves.

To implement a follower system, we create a table containing `id`, `user_id` and `follower_id` columns. `user_id` points to the user who is being followed. In this table, we have to implement this check:

```sql
CHECK (user_id != follower_id)
```

You can also check if a user follows another user only once:

```sql
UNIQUE(user_id, follower_id)
```

Remember to name the columns properly so that it would be understood easily. `user_id` might better be replaced by `followed_id` or anything else.

Let's now implement the followers table design:

```sql
Table followers {
  id SERIAL [pk, increment]
  created_at TIMESTAMP
  followed_id INTEGER [ref: > users.id]
  follower_id INTEGER [ref: > users.id]
}
```

# Implementing Design in Postgres

## Creating tables with checks

### Creating the users table

We are now going to create the users table. You can use the query below:

```sql
 CREATE TABLE users (
	id SERIAL PRIMARY KEY,
	created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
	updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
	username VARCHAR(30) NOT NULL,
	bio VARCHAR(400),
	avatar VARCHAR(200),
	phone VARCHAR(25),
	email VARCHAR(40),
	password VARCHAR(50),
	status VARCHAR(15),
	CHECK(COALESCE(phone, email) IS NOT NULL)
)
```

Note that `CURRENT_TIMESTAMP` is a Postgres reserved variable name which holds the value of the current timestamp and we have provided it as a default value of `created_at` column if the value is not provided by the client who is creating the user row.

Also note that the `CHECK` at the end is making sure that at least one of the fields (phone or email) is provided with a value and not both of them are left null.

> Reminder: `NOT NULL` means that a value must be provided (empty strings are values).
>
> Reminder: `DEFAULT` means provide a default value if an `INSERT` statement does not give one.
>
> Note: If it does not matter if a value exists, you don't need to mark `NOT NULL` or provide `DEFAULT`.
>
> Note: When you always want a value but it should be optional, you can apply both `NOT NULL` and `DEFAULT`.

### Creating the posts table

You can use the query below to create the posts table:

```sql
CREATE TABLE posts (
	id SERIAL PRIMARY KEY,
	created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
	updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
	url VARCHAR(200) NOT NULL,
	caption VARCHAR(240),
	lat REAL CHECK(lat IS NULL OR (lat >= -90 AND lat <= 90)),
	lng REAL CHECK(lat IS NULL OR (lat >= -180 AND lat <= 180)),
	user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE
);
```

> Note that valid values of geographic latitude can go between -90 and 90. Valid values for geographic longitude go between -180 and 180.

> Reminder: If rules around validating a value might change frequently, you don't need to add database-level validation. Also, if rules around validating the values are complex, you had better implement them on the server application. However, if you want to make sure we have the right type or domain of values, you can use database-level validation. This is what we are doing for the `lat` and `lng` columns.
>
> Reminder: `ON DELETE CASCADE` makes sure if a user is deleted from the database, all posts related to that user will be deleted also.

### Creating the comments table

Here is the query to create the comments table:

```sql
CREATE TABLE comments (
	id SERIAL PRIMARY KEY,
	created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
	updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
	contents VARCHAR(240) NOT NULL,
	user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
	post_id INTEGER NOT NULL REFERENCES posts(id) ON DELETE CASCADE
)
```

### Creating the likes table

Here is the query to create the likes table:

```sql
CREATE TABLE likes (
	id SERIAL PRIMARY KEY,
	created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
	user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
	post_id INTEGER REFERENCES posts(id) ON DELETE CASCADE,
	comment_id INTEGER REFERENCES comments(id) ON DELETE CASCADE,
	CHECK(
		COALESCE((post_id)::BOOLEAN::INTEGER, 0)
		+
		COALESCE((comment_id)::BOOLEAN::INTEGER, 0)
		= 1
	),
	UNIQUE(user_id, post_id, comment_id)
)
```

> Question: what is this check doing differently than the check I implemented in the users table?

### Creating the photo tags and caption tags tables

To create the photo tags table you can use this query:

```sql
CREATE TABLE photo_tags (
	id SERIAL PRIMARY KEY,
	created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
	updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
	user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
	post_id INTEGER NOT NULL REFERENCES posts(id) ON DELETE CASCADE,
	x INTEGER NOT NULL,
	y INTEGER NOT NULL,
	UNIQUE (user_id, post_id)
)
```

> Reminder: the `UNIQUE` check is making sure that a user gets tagged only once in a single post.

To create the caption tags table you can use this query:

```sql
CREATE TABLE caption_tags (
	id SERIAL PRIMARY KEY,
	created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
	user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
	post_id INTEGER NOT NULL REFERENCES posts(id) ON DELETE CASCADE,
	UNIQUE (user_id, post_id)
)
```

### Creaing the hashtags table

To create a table for hashtags you can do this:

```sql
CREATE TABLE hashtags (
	id SERIAL PRIMARY KEY,
	created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
	title VARCHAR(20) NOT NULL UNIQUE
)
```

To create a table for post hashtags you can do this:

```sql
CREATE TABLE hashtags_posts (
	id SERIAL PRIMARY KEY,
	hashtag_id INTEGER REFERENCES hashtags(id) ON DELETE CASCADE,
	post_id INTEGER REFERENCES posts(id) ON DELETE CASCADE,
  UNIQUE(hashtag_id, post_id)
)
```

> The `UNIQUE` check is making sure a hashtag will be recorded only once on a single post.

To create the table for followers you can do this:

```sql
CREATE TABLE followers (
	id SERIAL PRIMARY KEY,
	created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
	leader_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
	follower_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
	UNIQUE(leader_id, follower_id)
)
```

> The `UNIQUE` check is making sure a user can follow another user only once.

# Managing the database

## Inserting data from a backup file

Let's first insert a lot of fake data into our implemented database design.

A backup file compatible with Postgres and PGAdmin usually has the `.sql` file extension. In order to insert this file into our implemented tables, you need to right-click on the database, click on `restore`, then locate and select the file, then turn on the options below:

1. Data options: type of objects: only data (on)
2. Data options: do not save: owner (on)
3. Query options: single transaction (on)
4. Options: disable: triggers (on)
5. Options: miscellaneous / behavior: verbose messages (on)

## Restoring a database if accidentally deleted

# Understanding the internals of Postgres

In order to get a good performance out of your Postgres database, you have to understand what goes on inside it:

1. You have to understand how information is being stored on hard disk, and how it gets accessed.
2. What tools we have and how they work. Understanding indexes and how they work.
3. How queries are interpretted by the database and how they actually get executed.

## Where does Postgres stores data on hard disk

You can use the `SHOW` clause anytime you want to pull one configuration option out of your database.

```sql
SHOW data_directory;
-- returns C:/Program Files/PostgreSQL/17/data
```

In this directory, all the data that you have in your database is located inside the `base` folder. There are multiple folders with numeric names assigned to them, each containing data related to a separate database. If you want to understand what these numbers are you can run this query:

```sql
SELECT oid, datname
FROM pg_database;
-- returns the same set of directories you found in your file explorer.
```

Among them, you see `template0` and `tewmplate1` but we will discuss these later. You can also see the `instagram` database that you created previously. Inside this directory, you will find a lot of files that contain all the raw data of your database. But what actually are these files and what is stored in each? You can understand that by running another query:

```sql
SELECT * FROM pg_class;
```

Each of the rows you get from this query contains information about one of those files. Each file represents one individual object inside your database. The objects that you have in your database are not just tables. We also have objects for indexes, sequences, primary keys, and a couple of other things as well. You can find, for example, the file related to the users table by looking into the `relname` column and find its `oid`. Then you can go back to the file explorer and find the file there. Let's not understand how information is actually stored in this data. But before that, let's understand a little piece of terminology.

### Heaps, blocks and tuples

#### Heap or heap file

This is a file that contains all the data (rows) of a table. A heap data structure is very different than a heap file.

#### Tuple or item

This is an individual row from a table.

#### Block or page

The heap file is divided into many different blocks or pages. Each page/block stores some number of tuples, items or rows. By default, each block/page is 8kb in size regardless of how many items are stored inside it.

But why do we have this structure in our database?

## Block data layout

Let's now go deeper and understand what goes on in a block. We are going to understand how a block is physically stored on the hard drive. So let's take the file `22445` as an example. It is a heap file and there are a couple of blocks in it. We are now concentrating on one block.

When we talk about block 1, we are actually thinking about some information that is being stored on the hard disk of your computer. You hard disk stores information as binary (0s and 1s). When we talk about the structure of a block, we are essentially talking about what different 0s and 1s inside this block are actually being used to store what piece of information. It is a continuous series of 0s and 1s.

A collection of 0s and 1s at the very beginning of the block represent information about the block itself. The next set of 0s and 1s contain information about the actual data that is stored in this block, so that is information about the actual rows, but it does not contain information about the rows themselves (so no usernames, no IDs). It simply says where you can find the different rows that are stored in this block.

Then there is huge area of empty space in the block. This is a series of 0s and 1s that are not being used by the block right now. This space can eventually be used to assign some kind of user data or whatever we are trying to store inside the table.

Finally, at the very end of the block, is the actual data itself. Again it is a series of 0s and 1s where information about tuples are stored.

Let's now take a look a an actual block stored on your hard drive.

## Heap file layout

Let's map out how Postgres stores data at the binary level.
